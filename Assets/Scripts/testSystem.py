# -*- coding: utf-8 -*-
"""Nuevo Castle Rescue - Random.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KP7NP8G5mgeifBpF9nnr6DrJ1UKNUmw9

# **Castle-rescue**

### **Objetivo del sistema (Random)**
Desarrollar un sistema donde un equipo de 6 agentes llamados " Soldados " con desiciones aleatorias busquen y rescaten victimas de un castillo siendo atacado por Mountruos.

Esta versión nos servira como línea base para comparar contra la versión “estrategica”

### **Caracteristicas del sistema**

**Tablero**: 10×8 celdas contando el anillo exterior (interior 8×6); el perímetro permite entradas/salidas y el conteo de rescates.

**Vecindad**: Von Neumann (N/S/E/O), sin diagonales.

**POI en tablero:** siempre debe haber 3 en total (POI sin revelar + víctimas reveladas).

**AP**: cada héroe tiene 4 AP por turno y puede guardar AP no usados hasta 4 al finalizar, el agente puede tener un máximo de 8AP.

**Acciones principales:**
- Moverse a una casilla libre (1 AP)
- Matar monstruo (2 AP)
- Dañar a un monstruo y convertirlo en "tumba" (1 PA)
- Destruir “tumba” (1 AP)
- Abrir/cerrar puerta (1 AP)
- Revelar POI (0 AP),
- cargar víctima (mover cuesta 2 AP por celda),
- Dañar muro (2 AP)
- Romper muro completamente (4 AP)

**Ciclo de turno global**:
1. Héroes (uno por uno) Realizan acciones →
2. Dinámica del entorno (propagación/transformación de tumbas a Mounstruos, daño a muros/puertas con "invocaciones", pérdida de víctimas si aplica) →
3. Reposición de POI (si aplica), siempre debe haber 3 POI sobre el tablero.

**Condiciones de fin de la simulación**:

* Victoria al rescatar 7 victimas

* Derrota si se pierden 4 victimas o colapso por exceder umbral de daño estructural (configurable).

`Nota: Estas reglas no cambian entre baseline y eficiente; lo que cambia es cómo decide cada agente.`

**Comportamiento del agente(Random)**:

1. En el primer turno los agentes colocados en puertas entran al edificio.

    - Si el agente no tiene una entrada cercana que le permita entrar al edifício con menos de 4 AP (un turno), buscara romper o dañar una pared cercana.

2. Dentro del edificio el agente se mueve de manera aleatoria a celdas adyacentes (arriba, abajo, izquierda, derecha).

3. Si el agente encuentra una tumba en su camino la elimina (1 AP), si no tiene puntos de accion suficientes los guarda para el siguiente turno.

4. Si el agente encuentra un monstruo en su camino lo elimina (2 AP) o lo convierte en tumba (1 AP), si no tiene puntos de accion suficientes los guarda para el siguiente turno.

6. El agente puede decidir romper o dañar una pared siempre y cuando no se exceda el 60% del factor de riesgo.

7. Si el agente encuentra una puerta la abre (1 AP) , si no tiene puntos de accion suficientes los guarda para el siguiente turno.

8. Si el agente encuentra un POI lo revela (0 AP).

9. Si el POI es una falsa alarma el agente lo ignora y se sigue moviendo.

10. Si el punto de interes es una victima la carga (2 AP), si no tiene puntos de accion suficientes los guarda para el siguiente turno.

11. Si el agente esta cargando una victima, busca una salida y evacua a la victima, si no tiene puntos de accion suficientes para moverse los guarda para el siguiente turno.
"""

# !pip install numpy scipy matplotlib seaborn scikit-learn mesa==3.0 -q
# !pip install --pre mesa[viz]

# Commented out IPython magic to ensure Python compatibility.
# Requiero Mesa > 3.0.3
# Importamos las clases que se requieren para manejar los agentes (Agent) y su entorno (Model).
# Cada modelo puede contener múltiples agentes.
from mesa import Agent, Model

# Debido a que necesitamos que existe un solo agente por celda, elegimos ''SingleGrid''.
from mesa.space import SingleGrid

# Con ''RandomActivation'', hacemos que todos los agentes se activen de forma aleatoria.
# from mesa.time import RandomActivation
# Con ''BaseScheduler'', hacemos que los agentes se activen siempre en el mismo orden.
from mesa.time import BaseScheduler

# Haremos uso de ''DataCollector'' para obtener información de cada paso de la simulación.
from mesa.datacollection import DataCollector

#PARA COLORES
from matplotlib.colors import ListedColormap, BoundaryNorm

# Haremos uso de ''batch_run'' para ejecutar varias simulaciones
from mesa.batchrunner import batch_run

# matplotlib lo usaremos crear una animación de cada uno de los pasos del modelo.
# %matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
plt.rcParams["animation.html"] = "jshtml"
matplotlib.rcParams['animation.embed_limit'] = 2**128

# Importamos los siguientes paquetes para el mejor manejo de valores numéricos.
import numpy as np
import pandas as pd
import seaborn as sns
import random

sns.set()

# Definimos otros paquetes que vamos a usar para medir el tiempo de ejecución de nuestro algoritmo.
import time
import datetime

"""# **Definir Clase Agente**"""

class SoldierAgent(Agent):
    def __init__(self, agent_id, model):
        super().__init__(model)

        self.agent_id = agent_id

        self.ap = 4
        self.saved_ap = 0
        self.carrying_victim = False
        self.agent_in_building = False

        #Variables para contabilizar métricas
        self.extinguished_fire = 0
        self.extinguished_smoke = 0
        self.broken_walls = 0
        self.opened_dors = 0
        self.victims_saved = 0
        self.visited_cells = 1

    #REVISAR SI NORTE NO DEBERIA SER -1 Y SUR +1 NOTA PARA FER
    def get_direction(self, actual_pos, position):
        dx = position[0] - actual_pos[0]
        dy = position[1] - actual_pos[1]

        if dx == +1: return 'E'
        elif dx == -1: return 'W'
        elif dy == -1: return 'N'
        elif dy == +1: return 'S'
        return None

    def wall_blocking(self, position):
        direction = self.get_direction(self.pos, position)
        if not direction:
            return False

        actual_x, actual_y = self.pos

        #Verifica si hay paredes en la dirección que se desea mover
        wall_state = self.model.walls[actual_y, actual_x][direction]

        # Pared dañada o completa bloquean
        return wall_state in [2, 4]

    def handle_door(self, position):
        direction = self.get_direction(self.pos, position)
        if not direction:
            return False

        actual_x, actual_y = self.pos

        #Verifica si hay puertas en la dirección que se desea mover
        door_state = self.model.doors[actual_y, actual_x][direction]

        #Si la puerta esta cerrada y tiene AP suficientes
        if door_state == 1 and self.ap >= 1:
            #Abre la puerta
            self.model.doors[actual_y, actual_x][direction] = 2

            #Abrir puerta desde la celda vecina tambien
            target_x, target_y = position
            opposite_directions = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}
            self.model.doors[target_y, target_x][opposite_directions[direction]] = 2

            #Gasto AP
            self.ap -= 1
            self.opened_dors += 1
            print(f"Agent {self.unique_id} opened door at direction {direction} actual AP {self.ap}")

            return True

        return False

    def handle_monster_tomb(self, position):
        target_x, target_y = position

        if self.wall_blocking(position):
            print(f"Agente {self.unique_id} no pudo atacar en {position}: bloqueado por pared")
            return False

        monster_state = self.model.fire[target_y, target_x]

        if monster_state == 2 and self.ap >= 1:
            if self.ap >= 2:
                #Matar mostruo
                self.model.fire[target_y, target_x] = 0
                self.ap -= 2
                self.extinguished_fire += 1
                print(f"Agent {self.unique_id} killed monster at {position} actual AP {self.ap}")
            else:
                # Convertir a tumba
                self.model.fire[target_y, target_x] = 1
                self.ap -= 1
                self.extinguished_smoke += 1
                print(f"Agent {self.unique_id} damaged monster to tomb at {position} actual AP {self.ap}")

            return True

        elif monster_state == 1 and self.ap >= 1:
            #Destruye tumba
            self.model.fire[target_y, target_x] = 0
            self.ap -= 1
            self.extinguished_smoke += 1
            print(f"Agent {self.unique_id} destroyed tomb at {position} actual AP {self.ap}")
            return True

        return False

    def handle_POI(self, position):
        target_x, target_y = position

        if self.wall_blocking(position):
            print(f"Agente {self.unique_id} no pudo revelar POI en {position}: bloqueado por pared")
            return False

        poi_state = self.model.pois[target_y, target_x]
        revealed_poi = self.model.poi_type[target_y, target_x]

        if poi_state == 1:
            #Revelar POI
            self.model.pois[target_y, target_x] = revealed_poi

            if revealed_poi == 3:
                print(f"POI at {position} revealed: VICTIM")

            elif revealed_poi == 2:
                print(f"POI at {position} revealed: FALSE ALARM")
                self.model.pois[target_y, target_x] = 0

            return True

        if revealed_poi == 3 and not self.carrying_victim:
            if self.ap >= 2:
                self.carrying_victim = True
                self.model.pois[target_y, target_x] = 0
                self.ap -= 2
                print(f"Agent {self.unique_id} picked up victim at {position} actual AP {self.ap}")
                return True

        return False


    def handle_walls(self, position):
        direction = self.get_direction(self.pos, position)
        if not direction:
            return False

        actual_x, actual_y = self.pos

        #Verifica si hay paredes en la dirección que se desea mover
        wall_state = self.model.walls[actual_y, actual_x][direction]

        #Si la pared esta completa y tiene suficientes AP
        if wall_state == 4:
            if self.ap >= 4:
                #Rompe la pared
                self.model.walls[actual_y, actual_x][direction] = 0
                #Romper pared desde la celda vecina tambien
                target_x, target_y = position
                opposite_directions = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}
                self.model.walls[target_y, target_x][opposite_directions[direction]] = 0

                #Se restan AP
                self.ap -= 4
                self.broken_walls += 1
                # 4 con 4 AP (romper): +4 YESS
                self.model.damage_counter += 4

                print(f"Agent {self.unique_id} completely broke wall at direction {direction} actual AP {self.ap}")
                return True

            #Si la pared esta completa y tiene 2 AP
            elif self.ap >= 2:
                  #Daña la pared
                  self.model.walls[actual_y, actual_x][direction] = 2

                  #Dañar pared desde la celda vecina tambien
                  target_x, target_y = position
                  opposite_directions = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}
                  self.model.walls[target_y, target_x][opposite_directions[direction]] = 2

                  #Se restan AP
                  self.ap -= 2

                  # 4 con 2 AP (dañar): +2 YESS
                  self.model.damage_counter += 2

                  print(f"Agent {self.unique_id} damaged wall at direction {direction} actual AP {self.ap}")
                  return True

        #Si la pared ya esta dañada y tiene suficientes AP
        elif wall_state == 2:
            if self.ap >= 2:
                #Daña más la pared y la rompe completamente
                self.model.walls[actual_y, actual_x][direction] = 0
                #Romper pared desde la celda vecina tambien
                target_x, target_y = position
                opposite_directions = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}
                self.model.walls[target_y, target_x][opposite_directions[direction]] = 0

                #Se restan AP
                self.ap -= 2
                self.broken_walls += 1

                # 2 con 2 AP (romper): +2 YESS
                self.model.damage_counter += 2

                print(f"Agent {self.unique_id} damaged wall at direction {direction} actual AP {self.ap}")
                return True

        return False

    def move(self):
        actual_pos = self.pos
        actual_x, actual_y = self.pos

        possible_positions = self.model.grid.get_neighborhood(self.pos, moore=False, include_center=False)
        options = np.random.permutation(len(possible_positions))

        #No tiene AP
        if self.ap < 1:
            return

        for i in options:
            position = possible_positions[i]
            target_x, target_y = position

            direction = self.get_direction(actual_pos, position)

            door_state = self.model.doors[actual_y, actual_x][direction]
            monster_state = self.model.fire[target_y, target_x]
            poi_state = self.model.pois[target_y, target_x]
            wall_state = self.model.walls[actual_y, actual_x][direction]

            #La dirección no es valida
            if not direction:
                continue

            #Puerta cerrada
            if door_state == 1:
                if not self.handle_door(position):
                    #No tiene AP suficientes
                    continue

            #Hay monstruo o tumba
            if monster_state > 0:
                if not self.handle_monster_tomb(position):
                    #No tiene AP suficientes
                    continue

            #Hay POI
            if poi_state >= 1:
                if not self.handle_POI(position):
                    #No tiene AP suficientes
                    continue

            #Pared completa o dañada
            if wall_state == 4 or wall_state == 2:
                if not self.handle_walls(position):
                    continue

            #Moverse si esta cargando victima
            if self.ap >= 2 and self.carrying_victim == True:
                if self.model.grid.is_cell_empty(position):
                    self.model.grid.move_agent(self, position)
                    self.ap -= 2
                    self.visited_cells += 1
                    print(f"Agent {self.unique_id} moved to {position} with victim actual AP {self.ap}")
                    break

            #Moverse si no esta cargando victima, la celda está vacía y tiene AP
            if self.ap >= 1 and self.model.grid.is_cell_empty(position):
                self.model.grid.move_agent(self, position)
                self.ap -= 1
                self.visited_cells += 1
                print(f"Agent {self.unique_id} moved to {position} actual AP {self.ap}")
                break

    def move_to_exterior(self, exterior):
        (x, y) = self.pos
        # Select the first exterior position as the target
        if exterior and isinstance(exterior, list):
            target_exterior = min(self.model.exterior,
                  key=lambda e: abs(e[0]-x)+abs(e[1]-y))
        elif exterior and isinstance(exterior, tuple):
             target_exterior = exterior
        else:
            return

        (x2, y2) = target_exterior

        #Moverse en el eje X hacia el exterior
        if x < x2:
            x += 1
        elif x > x2:
            x -= 1

        #Moverse en el eje Y hacia el exterior
        if y < y2:
            y += 1
        elif y > y2:
            y -= 1

        #Nueva posición del agente después de moverse un paso
        new_pos = (x, y)

        direction = self.get_direction((x, y), new_pos)
        if not direction:
            return
        door_state = self.model.doors[y, x][direction]
        monster_state = self.model.fire[new_pos[1], new_pos[0]]
        poi_state = self.model.pois[new_pos[1], new_pos[0]]
        wall_state = self.model.walls[y, x][direction]

        if door_state == 1 and not self.handle_door(new_pos):
            return
        if monster_state > 0 and not self.handle_monster_tomb(new_pos):
            return
        if poi_state >= 1 and not self.handle_POI(new_pos):
            return
        if wall_state in (4, 2) and not self.handle_walls(new_pos):
            return

        #Si la celda esta vacía mover el agente a la nueva posición
        if self.ap >= 2 and self.model.grid.is_cell_empty(new_pos):
            self.model.grid.move_agent(self, new_pos)
            self.ap -= 2
            self.visited_cells += 1
            print(f"Agent {self.unique_id} moved towards exterior {new_pos} with victim actual AP {self.ap} exterior function")

    def step(self):

        #REVISAR SI MANDAR AQUI IGUAL Finish Game
        if self.model.finish_game() == True:
            return

        (x, y) = self.pos

        #Sumar AP guardados (máximo 8 AP total)
        self.ap = min(self.ap + self.saved_ap, 8)
        self.saved_ap = 0

        print(f"Agent {self.unique_id} starting turn with {self.ap} AP at position {self.pos}")

        #Verificar si carga victima
        if self.carrying_victim:
            print(f"Entra a la función cuando carga una victima")
            #Si esta en el exterior del edificio la deja
            if self.pos in self.model.exterior:
                self.carrying_victim = False
                self.victims_saved += 1
                print(f"Agent {self.unique_id} leve victim at position {self.pos}")
            else:
                print(f"Llama a la función de moverse hacia el exterior")
                self.move_to_exterior(self.model.exterior)


        self.move()

        #staged_activation

        #Guardar AP no utilizados
        self.saved_ap = self.ap
        #Resetear AP
        self.ap = 4

        #-----llamar metodos de fuego, Poi Incendiados y Agentes incendiados

        self.model.propagacion_del_fuego()
        self.model.agentes_incendiados()
        self.model.posicionamiento_POI()
        self.model.poi_incenciados()

"""# **Creacion clase Modelo (Entorno)**

**Entorno**

Grid 10×8 con: celdas interiores/exteriores

 muros:
 * 0 = Sin daño
 * 1 = fracturado
 * 2 = destruido

 puertas:
 * 0 = cerrada
 * 1 = abierta

**Entidades:**
1. Soldados
2. POI (víctimas/falsas alarmas),
3. monstruos (humo/fuego).

**Variables globales: **
1. víctimas rescatadas/perdidas
2. daño estructural acumulado,
3. turno/step,
4. POI visibles/ocultos.

**Dinámica del entorno:** después de acciones de los soldados, propagación/transformación de humo/monstruo (eventos que pueden dañar muros/puertas y ocasionar pérdida de víctimas en celdas afectadas); reposición de POI hasta 3 en tablero; verificación de condiciones de fin.

**Inicialización:**
1. cargar mapa (muros/puertas/entradas
2. colocar héroes en exterior válido
3. asegurar 3 POI en tablero
4. ubicar monstruos iniciales.

**DataCollector:**

Modelo (por step): Victimas rescatadas/perdidas, daño acumulado, numero de steps

Agente (por step ) : AP usados/guardados, víctimas rescatadas, steps, eficiencia

## **Crear matriz "visualizable"**
"""

# Mapa de categorías:
# 0 = vacío
# 1 = humo
# 2 = fuego
# 3 = POI sin revelar
# 4 = POI víctima
# 5 = POI falsa alarma
# 6 = agente

def get_grid(model):
    H, W = model.grid.height, model.grid.width
    M = np.zeros((H, W), dtype=np.int8)

    # Capa fuego/humo
    M[model.fire == 1] = 1
    M[model.fire == 2] = 2

    # Capa POIs (encima de fuego/humo)
    M[model.pois == 1] = 3
    M[model.pois == 3] = 4
    M[model.pois == 2] = 5

    # Capa agentes (encima de todo)
    for ag in model.schedule.agents:
        x, y = ag.pos
        M[y, x] = 6

    return M

'''#Llenamos la grid con comida
def get_grid(model):
    grid = np.zeros((model.grid.height, model.grid.width))
    grid += model.fire
    grid += model.pois
    for content, (x,y) in model.grid.coord_iter():
        if isinstance(content, SoldierAgent):
            grid[y][x] = 3
    return grid'''

class CastleRescueModel(Model):

    def __init__(self, width = 10 , height = 8, agents = 6): #Columnas(x), filas(y)
        super().__init__()

        #Grid solo para un soldado por celda y sin grid toroidal
        self.grid = SingleGrid(width, height, torus=False)#grid no toroidal

        #Por ahora el posicionamiento de agentes sera Random
        #Pero debemos cambiarlo
        self.schedule = BaseScheduler(self)

        # -----------------Exterior del edificio-----------------------------------------

        self.exterior = [
            (0,0), (1,0), (2,0), (3,0), (4,0), (5,0), (6,0), (7,0), (8,0), (9,0),
            (0,7), (1,7), (2,7), (3,7), (4,7), (5,7), (6,7), (7,7), (8,7), (9,7),
            (0,1), (0,2), (0,3), (0,4), (0,5), (0,6),
            (9,1), (9,2), (9,3), (9,4), (9,5), (9,6)
        ]

        # ------------------Matriz Fuego / Humo------------------------------------------
        #Valor de la celda de la matriz FUEGO:
        #     0 = celda interior vacía (sin humo ni fuego)
        #     1 = humo
        #     2 = fuego


        # Crear Mapa con recursos de Mounstruo/Tumba
        # Los arreglos se indexan como [fila, columna]
        self.fire = np.zeros((height, width))#0/1/2 Important H y W para buena impresion

        #Lista de posicion de los primeros fuegos al iniciar la partida
        Pos_inicial_monsters = [
            (2, 2), (3, 2), (2, 3), (3, 3), (4, 3),
            (5, 3), (4, 4), (6, 5), (7, 5), (6, 6)
        ]

        for (x, y) in Pos_inicial_monsters:
        #Para checar el rango de la matriz por si la lista inicial cambia
        #if 0 <= x < width and 0 <= y < height:
            self.fire[y][x] = 2 # fila= y columna=x

        self.current_agent_idx = 0

    # ------------------Matriz Puntos de Interes------------------------------------------
    #Valor de la celda de la matriz POI:
        #     0 = Vacío
        #     1 = POI sin rebelar
        #     2 = POI Falsa Alarma
        #     3 = POI con Victima

        self.pois = np.zeros((height, width))

        #Fer
        self.poi_type = np.zeros((height, width))

        self.victims_placed = 0
        self.false_alarms_placed = 0
        self.max_victims = 10
        self.victims = 10
        self.max_false_alarms = 5
        self.false_alarms = 5
        self.victims_dead = 0

        #Lista de posicion de los primeros fuegos al iniciar la partida
        Pos_inicial_POI = [
            (4, 2), (1, 5), (8, 5),
        ]

        for (x, y) in Pos_inicial_POI:
        #Para checar el rango de la matriz por si la lista inicial cambia
        #if 0 <= x < width and 0 <= y < height:
            self.pois[y][x] = 1 # fila= y columna=x


        self.random_POI()

    # ------------------Matriz de objetos Puertas----------------------------------------
        #Valor de la celda de la matriz Puertas:
        #     0 = Sin Puerta
        #     1 = Cerrada
        #     2 = Abierta

        self.doors = np.empty((height, width),dtype=object)
        #Para inicializar todo sin puertas
        for y in range(height):
            for x in range(width):
                self.doors[y][x] = {'N': 0, 'E': 0, 'S': 0, 'W': 0}

        #Para tambien actualizar la misma puerta en el vecino
        vecinos = {'N': (0, -1), 'S': (0, +1), 'E': (1, 0), 'W': (-1, 0)}
        lado_op   = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}

        # Formato: (x, y, lado, estado)
        Puertas_iniciales = [ (1, 3, 'W', 2), (3,6,"S",2), (8,4,"E",2),
        (6, 1,"N",2), (2, 3,"E",1), (3, 1,"E",1), (5, 2,"E",1), (6, 4,"E",1),
        (5, 6,"E",1), (7, 6,"E",1), (8, 2,"S",1), (4, 4,"S",1)
        ]

        # Colocación y sincronización automática con la celda vecina
        for (x, y, d, state) in Puertas_iniciales:
                self.doors[y, x][d] = state
                dx, dy = vecinos[d]
                nx, ny = x + dx, y + dy
                if 0 <= nx < width and 0 <= ny < height:
                    self.doors[ny, nx][lado_op[d]] = state


    # ------------------Matriz de objetos Paredes----------------------------------------
        #Valor de la celda de la matriz Paredes:
        #     0 = Pared Rota
        #     2 = Pared Dañada
        #     4 = Pared Completa

        #VARIABLE GLOBAL DE DAÑO
        self.damage_counter = 0

        self.walls = np.empty((height, width),dtype=object)
        #Para inicializar todo sin puertas
        for y in range(height):
            for x in range(width):
                self.walls[y][x] = {'N': 0, 'E': 0, 'S': 0, 'W': 0}

        #Para tambien actualizar la misma puerta en el vecino
        #vecinos = {'N': (0, 1), 'S': (0, -1), 'E': (1, 0), 'W': (-1, 0)}
        #lado_op   = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}

        # Formato: (x, y, lado, estado)
        Walls_iniciales = [ (1, 1, 'W', 4), (1, 1, 'N', 4), (1, 2, 'W', 4),
        (1, 4, 'W', 4), (1, 4, 'S', 4), (1, 5, 'W', 4), (1, 6, 'W', 4),
        (1, 6, 'S', 4), (2, 1, 'N', 4), (2, 4, 'E', 4), (2, 4, 'S', 4),
        (2, 6, 'S', 4), (3, 1, 'N', 4), (3, 2, 'E', 4), (3, 2, 'S', 4),
        (3, 4, 'S', 4), (4, 1, 'N', 4), (4, 2, 'S', 4), (4, 6, 'S', 4),
        (5, 1, 'N', 4), (5, 1, 'E', 4), (5, 2, 'S', 4), (5, 4, 'S', 4),
        (5, 5, 'E', 4), (5, 6, 'S', 4), (6, 2, 'S', 4), (6, 3, 'E', 4),
        (6, 4, 'S', 4), (6, 6, 'S', 4), (7, 1, 'N', 4), (7, 2, 'S', 4),
        (7, 4, 'S', 4), (7, 5, 'E', 4), (7, 6, 'S', 4), (8, 1, 'N', 4),
        (8, 1, 'E', 4), (8, 2, 'E', 4), (8, 3, 'E', 4), (8, 4, 'S', 4),
        (8, 5, 'E', 4), (8, 6, 'E', 4), (8, 6, 'S', 4)
        ]

        # Colocación y sincronización automática con la celda vecina
        for (x, y, d, state) in Walls_iniciales:
                self.walls[y, x][d] = state
                dx, dy = vecinos[d]
                nx, ny = x + dx, y + dy
                if 0 <= nx < width and 0 <= ny < height:
                    self.walls[ny, nx][lado_op[d]] = state

        # --- Inicializar agentes ---
        for i in range(agents):
            agent = SoldierAgent(i + 1,self)
            self.schedule.add(agent)
            # Add the agent to a random empty cell
            pos = self.random_agent_position(width, height)
            while not self.grid.is_cell_empty(pos):
                pos = self.random_agent_position(width, height)
            self.grid.place_agent(agent, pos)

        self.datacollector = DataCollector(
            model_reporters={
                "Grid": get_grid,
                "Steps": lambda model : model.steps,
                "Victimas_muertas": lambda model: model.victims_dead
            },
            agent_reporters={
                "Celdas visitadas:": lambda agent: agent.visited_cells,
                "Victimas salvadas": lambda agent : agent.victims_saved,
                "Fuegos extinguidos:": lambda agent: agent.extinguished_fire,
                "Humos extinguidos:": lambda agent: agent.extinguished_smoke
            }
        )

    #FUERA DEL CONSTRUCTOR ABAJO

    #Posicionamiento (provicional) de los agentes SEGUN YO NO ES NECESARIO ASI
    def random_agent_position(self, width, height):
        side = self.random.randint(0, 3)
        if side == 0:  # top
            x = self.random.randint(0, width-1)
            y = 0
        elif side == 1:  # bottom
            x = self.random.randint(0, width-1)
            y = height-1
        elif side == 2:  # left
            x = 0
            y = self.random.randint(0, height-1)
        else:  # right
            x = width-1
            y = self.random.randint(0, height-1)
        return (x, y)

    # ------- Funciones del model------------

    #--------Funcion para fuegos

    #def InvocaciondeMounstruos

    #Funcion para cordenada aleatoria
    def _coord_aleatoria(self):
        x = random.randint(1,8)
        y = random.randint(1,6)
        return (x, y)

    def propagacion_del_fuego(self):
        #Elige una celda (objetivo) y ejecuta la transición según su estado:
            #0 → _fuego_estado_0
            #1 → _fuego_estado_1
            #2 → _fuego_estado_2_explosion (stub por ahora)
        print("\n\n<<<<<<< FUNCION DE PROP FUEGO >>>>>>>>")
        # 1) Elegir coordenada Objetivo

        x, y = self._coord_aleatoria()

        print(f"Objetivo: {(x, y)}")

        #state = self.fire[y, x]
        #print(f"State: {state}")

        estado = int(self.fire[y, x])

        print(f"Estado: {estado}")

        if estado == 0:
            return self._fuego_estado_0(y, x)
        elif estado == 1:
            return self._fuego_estado_1(y, x)
        else:  # estado == 2
            return self._fuego_estado_2_explosion(y, x)

    def _fuego_estado_0(self, y, x):
      print("\n\n<<<<<<< FUNCION DE FUEGO 0 >>>>>>>>")
      #Lógica:
        #Si NO hay vecinos con 2 -> la celda pasa a 1 (humo).
        #Si SÍ hay vecinos con 2:
          #Para cada vecino con 2:
            #Si hay PARED COMPLETA (=4) o dañada entre ambos -> bloquea -> seguimos revisando.
            #Si hay Puerta Cerrada (=1) entre ambos -> bloquea -> seguimos revisando.
            #Si pared esta ROTA (=0) -> enciende (2).
            #Si NO hay pared (valor 0 en el dict) -> enciende (2)
            #Revisamos si hay humos por prender adyacente al fuego que creamos y revisamos la cadena.
          #Si TODOS los vecinos en 2 estaban bloqueados por pared completa -> humo (1).

      #Revisar Vecinos
      vecinos = [
          (x+1, y),  # Este
          (x-1, y),  # Oeste
          (x, y-1),  # Norte
          (x, y+1),  # Sur
      ]

      # #Filtrar vecinos que están en FUEGO
      vecinos_en_fuego = [(nx, ny) for (nx, ny) in vecinos if int(self.fire[ny, nx]) == 2]

      #Sin vecinos en fuego -> HUMO (=1)
      if not vecinos_en_fuego:
          self.fire[y, x] = 1
          print(f"objetivo: {(x, y)} antes: {0} despues: {1} motivo: sin_vecino_en_fuego")
          return

      #Hay vecinos en fuego: por defecto HUMO, pero si alguno permite paso -> FUEGO

      self.fire[y, x] = 1        # valor por defecto si TODOS bloquean
      bloqueados_todos = True    # bandera: asumimos bloqueo total hasta demostrar lo contrario

      #saber de donde vienen los fuegos, para buscar la pared o puerta
      def dir_from_to(x0, y0, x1, y1):
          if x1 == x0+1 and y1 == y0:   return 'E'
          if x1 == x0-1 and y1 == y0:   return 'W'
          if x1 == x0   and y1 == y0-1: return 'N'
          if x1 == x0   and y1 == y0+1: return 'S'

      #Para cada Vecino
      for (nx, ny) in vecinos_en_fuego:
          d = dir_from_to(x, y, nx, ny)  #Direccion del vecino N, E, W, S

          #Leemos pared y puerta en el segmento (y,x) --d--> (ny,nx)

          # PAREDES: 4/2 Completa o dañada bloquea, 0 Sin pared / rota =deja pasar
          estado_pared  = int(self.walls[y, x].get(d, 0))
          print(f"pared: {self.walls[y, x]}")

          # PUERTAS: 0=sin puerta, 1=cerrada (bloquea), 2=abierta (deja pasar)
          estado_puerta = int(self.doors[y, x].get(d, 0))
          print(f"puerta: {self.doors[y, x]}")

          #Variable Bandera interna de bloqueo
          bloquea = False

          if estado_pared != 0:
              bloquea = True
          else:
              if estado_puerta == 1:
                  bloquea = True
              else:
                  bloquea = False # pared rota o sin pared y puerta abierta/sin puerta

          if bloquea == False:
              # Si NO bloquea, con UNO que deje pasar, esta celda se enciende
              self.fire[y, x] = 2
              bloqueados_todos = False

              # ──FASE NUEVA Propaga a HUMO=1 adyacente alcanzable ---BFS---

              # Guardamos lista de celdas encendidas en este paso
              encendidos = [(x, y)]

              # Usamos una cola para recorrer por casillas
              por_visitar = [(x, y)]

              #REVISAR SI SE TIENE QUE PONER SET
              visitados = {(x, y)}

              W, H = self.grid.width, self.grid.height

              def vecinos_lim(cx, cy):
                  nuevosVecinos = [(cx+1, cy), (cx-1, cy), (cx, cy-1), (cx, cy+1)]
                  return [(vx, vy) for (vx, vy) in nuevosVecinos if 0 <= vx < W and 0 <= vy < H]

              # Recorremos la cola de humos, expandiendo el fuego si no hay bloqueo
              while por_visitar:
                  # sacamos el siguiente origen de casilla
                  cx, cy = por_visitar.pop(0)

                  # miramos los 4 vecinos de esa casilla
                  for vx, vy in vecinos_lim(cx, cy):

                      # si ya revisamos esta casilla
                      if (vx, vy) in visitados:
                          continue

                      # Solo nos interesan vecinos que actualmente estén en HUMO (=1)
                      if int(self.fire[vy, vx]) != 1:
                          continue

                      # Revisar bloqueo en el segmento (cx,cy) --d--> (nx,ny)
                      d2 = dir_from_to(cx, cy, vx, vy)
                      pared  = int(self.walls[cy, cx][d2]) # 4/2 bloquea; 0 no bloquea
                      print(f"pared: {self.walls[y, x]}")

                      puerta = int(self.doors[cy, cx][d2]) # 1 bloquea; 0/2 no bloquea
                      print(f"puerta: {self.doors[y, x]}")

                      # Bloquea si pared != 0 (o sea 2 ó 4) o puerta cerrada (=1)
                      #Variable Bandera interna de bloqueo
                      bloquea = False

                      if estado_pared != 0:
                          bloquea = True
                      else:
                          if estado_puerta == 1:
                              bloquea = True
                          else:
                              bloquea = False # pared rota o sin pared y puerta abierta/sin puerta

                      if bloquea == True:
                          continue  # no se expande el fuego

                      # Si NO bloquea el humos se convierte en FUEGO
                      self.fire[vy, vx] = 2
                      encendidos.append((nx, ny))
                      visitados.add((vx, vy))

                      #Y ahora este nuevo fuego puede encender a sus HUMOS vecinos (se va a la cola)
                      por_visitar.append((vx, vy))

              # Una vez encendida y propagada, ya no hace falta revisar otros vecinos
              break

      # Salidas para revisar
      if bloqueados_todos:
          print(f"Origen: {(x, y)}\nAntes: {0}\nDespues: {1}\nMotivo: Bloqueado por pared/puerta")

      else:
          print(f"Objetivo: {(x, y)}\nAntes: {0}\nDespues: {2}\nDespues: {encendidos}\nMotivo: Fuego adyacente y paso libre")

    #Segunda funcion
    def _fuego_estado_1(self, y, x):
        print("\n\n<<<<<<< FUNCION DE FUEGO 1 >>>>>>>>")
        #Caso 'Fuego 1' (la casilla objetivo está en HUMO=1):
        #La celda objetivo pasa a FUEGO=2.
        #Todo HUMO=1 adyacente accesible (sin pared/puerta)
        #también pasa a FUEGO=2; y desde ellos se sigue propagando.
        #Reglas de bloqueo (mismas que en _fuego_estado_0):
        #Pared: 4/2 = BLOQUEA, 0 = NO bloquea.
        #Puerta: 1 = BLOQUEA, 0/2 = NO bloquea.
        #Nos regresa todas las celdas encendidas.

        #Encender la celda objetivo
        estado_inicial = int(self.fire[y, x])
        self.fire[y, x] = 2

        # Guardamos lista de celdas encendidas en este paso (para depurar)
        encendidos = [(x, y)]

        #BFS sobre celdas HUMO=1 alcanzables)
        # Usamos una cola para recorrer por casillas
        por_visitar = [(x, y)]                   # empezamos desde el objetivo ya encendido
        visitados = set([(x, y)])                # para no revisar dos veces la misma casilla

        # vecinos con límites porque la propagación puede alcanzar el borde
        def vecinos_humo(cx, cy):
            W, H = self.grid.width, self.grid.height
            vecinos = [(cx+1, cy), (cx-1, cy), (cx, cy+1), (cx, cy-1)]
            return [(nx, ny) for (nx, ny) in vecinos if 0 <= nx < W and 0 <= ny < H]

        # Dirección NESO desde (cx,cy) hacia (nx,ny)
        def dir_from_to(cx, cy, nx, ny):
            if nx == cx+1 and ny == cy:   return 'E'
            if nx == cx-1 and ny == cy:   return 'W'
            if nx == cx   and ny == cy-1: return 'N'
            if nx == cx   and ny == cy+1: return 'S'

        # Recorremos la cola de humos, expandiendo el fuego si no hay bloqueo
        while por_visitar:
            # sacamos el siguiente origen de casilla
            cx, cy = por_visitar.pop(0)

            # miramos los 4 vecinos de esa casilla
            for nx, ny in vecinos_humo(cx, cy):
                # si ya revisamos esta casilla
                if (nx, ny) in visitados:
                    continue


                # Solo nos interesan vecinos que actualmente estén en HUMO (=1)
                if int(self.fire[ny, nx]) != 1:
                    continue

                # Revisar bloqueo en el segmento (cx,cy) --d--> (nx,ny)
                d = dir_from_to(cx, cy, nx, ny)
                estado_pared  = int(self.walls[cy, cx][d])   # 4/2 bloquea; 0 no bloquea
                print(f"pared: {self.walls[y, x]}")
                estado_puerta = int(self.doors[cy, cx][d])   # 1 bloquea; 0/2 no bloquea
                print(f"puerta: {self.doors[y, x]}")

                # Bloquea si pared != 0 (o sea 2 ó 4) o puerta cerrada (=1)
                #Variable Bandera interna de bloqueo
                bloquea = False

                if estado_pared != 0:
                    bloquea = True
                else:
                    if estado_puerta == 1:
                        bloquea = True
                    else:
                        bloquea = False # pared rota o sin pared y puerta abierta/sin puerta

                if bloquea == True:
                    continue  # no se expande el fuego

                # Si NO bloquea el humos se convierte en FUEGO
                self.fire[ny, nx] = 2
                encendidos.append((nx, ny))
                visitados.add((nx, ny))

                #Y ahora este nuevo fuego puede encender a sus HUMOS vecinos (se va a la cola)
                por_visitar.append((nx, ny))

        # Salida para revisar
        print(f"Origen: {(x, y)}")
        print(f"Antes: {estado_inicial}")
        print(f"Despues: {int(self.fire[y, x])}")
        print(f"Encendidos: {encendidos}")
        print("motivo: FUEGO1_encendido_en_cadena")

        return

    #Tercera funcion
    def _fuego_estado_2_explosion(self, y, x):
        print("\n\n<<<<<<< FUNCION DE FUEGO 2 >>>>>>>>")
        #Explosión desde (x,y) en 2=fuego.
        #En cada dirección N,S,W,E:
          #Si el segmento bloquea (pared 4/2 o puerta 1):
              #pared: resta 2 al valor (mínimo 0) en ambos lados del segmento y detiene esa dirección
              #puerta cerrada: la abre (->2) en ambos lados del segmento y detiene esa dirección
          #Si NO bloquea (pared 0 y puerta !=1):
              #si la celda siguiente está en 2: seguir avanzando
              #si la celda siguiente está en 0 o 1: ponerla en 2 y detener esa dirección
        #Devuelve una traza con celdas encendidas y segmentos modificados.

        # Limites del tablero
        width  = self.grid.width
        height = self.grid.height

        # Direcciones para recorrer
        direcciones = [
            ('N', (0, -1)),
            ('S', (0, +1)),
            ('W', (-1, 0)),
            ('E', (+1, 0)),
        ]

        # Lado opuesto para sincronizar el segmento en la celda vecina
        casilla_opuesta = {'N':'S','S':'N','E':'W','W':'E'}

        encendidos = []         # lista de celdas que pasaron a 2 por la explosión
        paredes_dañadas = []    #Lista paredes dañadas
        puertas_abiertas = []   #Lista puertas abiertas

        #Funcion para encender cadena de humo, como lo ocupamos mucho lo hacemos funcion
        def encender_humo_en_cadena(ox, oy):
            W, H = self.grid.width, self.grid.height
            def vecinos_lim(cx, cy):
                vecinos_ady = [(cx+1,cy),(cx-1,cy),(cx,cy-1),(cx,cy+1)]
                return [(vx,vy) for (vx,vy) in vecinos_ady if 0 <= vx < W and 0 <= vy < H]

            def dir_from_to(cx,cy,nx,ny):
                if nx==cx+1 and ny==cy:   return 'E'
                if nx==cx-1 and ny==cy:   return 'W'
                if nx==cx   and ny==cy-1: return 'N'
                if nx==cx   and ny==cy+1: return 'S'

            #BFS sobre celdas HUMO=1 alcanzables)
            # Usamos una cola para recorrer por casillas
            por_visitar=[(ox,oy)]    # empezamos desde el objetivo ya encendido

            # para no revisar dos veces la misma casilla
            visitados={(ox,oy)}

            # Guardamos lista de celdas encendidas en este pass
            nuevos_encendidos=[]

            # Recorremos la cola de humos, expandiendo el fuego si no hay bloqueo
            while por_visitar:
                # sacamos el siguiente origen de casilla
                cx,cy=por_visitar.pop(0)

                # miramos los 4 vecinos de esa casilla
                for vx,vy in vecinos_lim(cx,cy):
                    # si ya revisamos esta casilla
                    if (vx, vy) in visitados:
                      continue

                    # Solo nos interesan vecinos que actualmente estén en HUMO (=1)
                    if int(self.fire[vy, vx]) != 1:
                        continue

                    # Revisar bloqueo en el segmento (cx,cy) --d--> (nx,ny)
                    d2 = dir_from_to(cx,cy,vx,vy)

                    pared  = int(self.walls[cy,cx][d2]) # 4/2 bloquea; 0 no bloquea
                    print(f"pared: {self.walls[y, x]}")

                    puerta = int(self.doors[cy,cx][d2]) # 1 bloquea; 0/2 no bloquea
                    print(f"puerta: {self.doors[y, x]}")

                    # Bloquea si pared != 0 (o sea 2 ó 4) o puerta cerrada (=1)
                    #Variable Bandera interna de bloqueo
                    bloquea = False

                    if estado_pared != 0:
                        bloquea = True
                    else:
                        if estado_puerta == 1:
                            bloquea = True
                        else:
                            bloquea = False # pared rota o sin pared y puerta abierta/sin puerta

                    if bloquea == True:
                        continue  # no se expande el fuego

                    # Si NO bloquea el humos se convierte en FUEGO
                    self.fire[vy,vx] = 2
                    nuevos_encendidos.append((vx,vy))
                    visitados.add((vx,vy))

                    #Y ahora este nuevo fuego puede encender a sus HUMOS vecinos (se va a la cola)
                    por_visitar.append((vx,vy))
            return nuevos_encendidos

        # Recorremos cada lado uno por uno
        for d,(dx,dy) in direcciones:
            cx,cy = x,y               # empezamos desde el origen en fuego

            while True:
                # Calcular la siguiente celda vecina en la direccion
                # nueva x, nueva y
                nx,ny = cx+dx, cy+dy

                # Si la siguiente celda esta fuera del tablero paramos
                if not (0 <= nx < width and 0 <= ny < height):
                    break

                # Revisar entre la casilla(cx,cy) y nuevo vecino(nx,ny):
                # Pared y puerta del lado 'd' en la celda (cx,cy)
                estado_pared  = int(self.walls[cy,cx][d])
                print(f"pared: {self.walls[y, x]}")

                estado_puerta = int(self.doors[cy,cx][d])
                print(f"puerta: {self.doors[y, x]}")

                bloquea = False

                if estado_pared != 0:
                    bloquea = True
                else:
                    if estado_puerta == 1:
                        bloquea = True
                    else:
                        bloquea = False # pared rota o sin pared y puerta abierta/sin puerta

                if bloquea == True:
                    #Si bloquea por PARED (2 o 4) -> dañamos pared (–2) en ambos lados
                    if estado_pared != 0:
                        antes = estado_pared
                        despues = estado_pared - 2

                        #Sumar daño al contador global
                        self.damage_counter += 2

                        # escribimos en ambos lados de la pared
                        self.walls[cy,cx][d] = despues
                        self.walls[ny,nx][casilla_opuesta[d]] = despues

                        #Añadir registro de la explosión
                        paredes_dañadas.append(((cx,cy), d, antes, despues))

                        # Si quedó rota (0), prende HUMO al otro lado
                        if despues <= 0 and int(self.fire[ny,nx]) == 1:
                            self.fire[ny,nx] = 2
                            #Toma registro de lo encendido
                            encendidos.append((nx,ny))

                            #Manda llamar funcion para prender en cadena
                            encendidos += encender_humo_en_cadena(nx,ny)

                    # Si bloquea por PUERTA  (1) -> abrirla (->2) en ambos lados
                    elif estado_puerta == 1:
                        self.doors[cy,cx][d] = 2
                        self.doors[ny,nx][casilla_opuesta[d]] = 2
                        #Añadir registro de la explosion
                        puertas_abiertas.append(((cx,cy), d))

                        #Manda llamar funcion para prender en cadena
                        if int(self.fire[ny,nx]) == 1:
                            self.fire[ny,nx] = 2
                            #Toma registro de lo encendido
                            encendidos.append((nx,ny))
                            #Manda llamar funcion para prender en cadena
                            encendidos += encender_humo_en_cadena(nx,ny)

                    # Al dañar (pared/puerta), la busqueda en esta dirección se detiene
                    break

                #Si NO bloquea vemos el estado de la casilla vecina (nx,ny)
                estado_vecino = int(self.fire[ny,nx])

                if estado_vecino == 2:
                    #Si el vecino ya es fuego, seguimos bucando en esta direccion
                    #y ahora la casilla vecina sera la que usaremos para bucar al nuevo vecino
                    cx,cy = nx,ny
                    continue

                # Si es 0 lo encendemos y detenemos la busqueda
                self.fire[ny,nx] = 2

                #Añadimos el registro de la explosion y todas las nuevas celdas encendidas
                encendidos.append((nx,ny))
                encendidos += encender_humo_en_cadena(nx,ny)
                break

        # Salida de informacion final
        print(f"Origen: {(x, y)}")
        print(f"Paredes dañadas: {paredes_dañadas}")
        print(f"Puertas abiertas: {puertas_abiertas}")
        print(f"Celdas encendidas: {encendidos}")
        print("motivo: EXPLOSION (con encendido de humos por apertura/rotura)")

        return

    #------------------ Puntos de Interes ------------------------------

    #--------Funcion para pois

    def posicionamiento_POI(self):
        print("\n\n<<<<<<< FUNCION POSICIONAMIENTO POIS >>>>>>>>")
        #Contar POIS en el tablero, sin revelar y revelados
        unrevealed = int((self.pois == 1).sum())
        false_alarms_revealed = int((self.pois == 2).sum())
        victims_revealed = int((self.pois == 3).sum())

        current_pois = unrevealed + false_alarms_revealed + victims_revealed
        pois_placed = self.victims_placed + self.false_alarms_placed

        #Si hay menos de 3 POI se posicionan más
        while current_pois < 3 and self.victims <= 10 and self.false_alarms <= 5:
            victims_left = self.max_victims - self.victims_placed
            false_alarms_left = self.max_false_alarms - self.false_alarms_placed

            #Si ya se colocaron todos los POI se detiene
            if victims_left == 0 and false_alarms_left == 0:
                break

            is_victim = False
            if victims_left > 0 and false_alarms_left > 0:
                poi_probability = victims_left / (victims_left + false_alarms_left)
                is_victim = np.random.random() < poi_probability
            elif victims_left > 0:
                is_victim = True
            elif false_alarms_left > 0:
                is_victim = False
            else:
                break

            attempts = 0
            placed = False
            while attempts < 100 and not placed:
                #Posicionamiento random de POI
                x = np.random.randint(1, 9)
                y = np.random.randint(1, 7)

                if self.pois[y, x] == 0:
                    cell_contents = self.grid.get_cell_list_contents([(x, y)])

                    if self.fire[y, x] == 2:
                        print(f"Apagando fuego en ({x}, {y}) para colocar POI")
                        self.fire[y, x] = 0

                    if len(cell_contents) == 0:
                        #Nuevo POI sin revelar
                        self.pois[y, x] = 1

                        if is_victim:
                            self.poi_type[y, x] = 3
                            self.victims_placed += 1
                            self.victims -= 1

                        else:
                            self.poi_type[y, x] = 2
                            self.false_alarms_placed += 1
                            self.false_alarms -= 1


                        current_pois += 1
                        pois_placed += 1
                        placed = True

                        print(f"Nuevo POI colocado en: ({x}, {y}), victimas colocadas: {self.victims_placed}, Falsas alarmas colocadas: {self.false_alarms_placed}")
                        break

                attempts += 1

            if not placed:
                print("No se pudo colocar el POI")
                break

    #--------Funcion para random POI

    def random_POI(self):
        poi_positions = []
        for y in range(1, 7):
            for x in range(1, 9):
                if self.pois[y, x] == 1:
                    poi_positions.append((x, y))

        for (x, y) in poi_positions:
            victims_left = self.max_victims - self.victims_placed
            false_alarms_left = self.max_false_alarms - self.false_alarms_placed

            if victims_left > 0 and false_alarms_left > 0:
                poi_probability = victims_left / (victims_left + false_alarms_left)
                if np.random.random() < poi_probability:
                    self.poi_type[y, x] = 3
                    self.victims_placed += 1
                else:
                    self.poi_type[y, x] = 2
                    self.false_alarms_placed += 1

            elif victims_left > 0:
                self.poi_type[y, x] = 3
                self.victims_placed += 1
            elif false_alarms_left > 0:
                self.poi_type[y, x] = 2
                self.false_alarms_placed += 1


    #------------------ Funcion para pois incendidados
    def poi_incenciados(self):
        print(f"Entra a la funcion de pois incendiados")
        poi_positions = []
        for y in range(1, 7):
            for x in range(1, 9):
                if self.pois[y, x] > 0 and self.fire[y, x] == 2:
                    poi_positions.append((x, y))

        for (x, y) in poi_positions:
            poi = self.pois[y, x]
            poi_type = self.poi_type[y, x]

            if poi_type == 3:
                self.victims_dead += 1
                print(f"Víctima revelada en ({x},{y}) murió por incendio. Total muertos: {self.victims_dead}")

            elif poi_type == 2:
                print(f"Falsa alarma en ({x},{y}) revelada por incendio.")

            # Borrar el POI de la celda incendiada
            self.pois[y, x] = 0
            self.poi_type[y, x] = 0

        if len(poi_positions) > 0:
            # Call posicionamiento_POI to replace the lost POI
            self.posicionamiento_POI()


    #Reposicionamiento de agentes Incendiados------------------------
    def agentes_incendiados(self):
      print("\n\n<<<<<<< FUNCION DE AGENTES INCENDIADOS >>>>>>>>")
      #Recoloca a los agentes cuya casilla actual tiene FUEGO (=2).
      #puertas_ext: lista de coordenadas destino.
    #no enviar agentes a una puerta que también tenga fuego.

      # Psiciones de reubicación
      puertas_ext = [(0, 3), (3, 7), (9, 4), (6, 0)]  # ← tu lista

      reubicados = []      # [{agente, de, a}]
      sin_espacio = []     # [{agente, pos}] si no encontró lugar

      width = self.grid.width
      height = self.grid.height

      # Recorremos a los agentes del scheduler
      for ag in list(self.schedule.agents):
          pos = ag.pos
          x, y = pos

          #Revisar si el agente no esta parado sobre una casilla con fuego se pasa al siguiente
          if int(self.fire[y, x]) != 2:
              print("<<<<<<< NADIE INCENDIADO >>>>>>>>")
              continue

          # Buscar la primera puerta libre
          movido = False
          for (px, py) in puertas_ext:
              # Si la celda no esta libre pasamos a la siguiente
              if not self.grid.is_cell_empty((px, py)):
                  continue
              # Si la celda tiene fuego pasamos a la siguiente
              if int(self.fire[py, px]) == 2:
                  continue

              # Movemos al agente
              self.grid.move_agent(ag, (px, py))
              reubicados.append({
                  "agente": getattr(ag, "unique_id", repr(ag)),
                  "de": (x, y),
                  "a": (px, py)
              })
              movido = True
              break

          if movido == False:
              # No había puerta disponible para el agente herido
              sin_espacio.append({
                  "agente": getattr(ag, "unique_id", repr(ag)),
                  "pos": (x, y)
              })

      return {
          "reubicados": reubicados,
          "sin_espacio": sin_espacio,
          "puertas_consideradas": puertas_ext
      }

    #Paso de la simulacion del modelo
    def step(self):
        self.datacollector.collect(self) # Primero recolecta los datos antes de moverse
        # Agent List
        agents_list = list(self.schedule.agents)
        # Error check
        if agents_list:
            # call only current agent
            agent = agents_list[self.current_agent_idx]
            agent.step()
            # Update Index
            self.current_agent_idx = (self.current_agent_idx + 1) % len(agents_list)

    #funcion condicion de termino
    def finish_game(self):
      print("\n\n<<<<<<< REVISION SI SE ACABO EL JUEGO >>>>>>>>")
      #Revisa las condiciones de paro del juego.
        #Gana si hay 7 personas salvadas.
        #Pierde si hay 4 muertos.
        #Pierde si el daño estructural llega a 48.
      #Devuelve: True si terminó, False si sigue.

      # Inicializa flags para datacollector
      self.finished = False
      self.win      = None
      self.reason   = None

      # Lee contadores globales del modelo
      danio = self.damage_counter
      print(f"Daño Actual: {self.damage_counter}")

      #Termina si salva a 7 victimas
      total_victims_saved = sum(agent.victims_saved for agent in self.schedule.agents)
      self.victims_saved = total_victims_saved
      if self.victims_saved >= 7:
          self.finished = True
          self.win      = True
          self.reason   = 'victims'
          self.running  = False
          print(f"GANASTE Victimas salvadas: {self.victims_saved}, Muertes: {self.victims_dead}, Daño {self.damage_counter}")
          return True

      #REVISAR
      #Termina si murieron 4 victimas
      if self.victims_dead >= 4:
          self.finished = True
          self.win      = False
          self.reason   = 'victims deads'
          self.running  = False
          print(f"PERDISTE Victimas salvadas: {self.victims_saved}, Muertes: {self.victims_dead}, Daño {self.damage_counter}")
          return True

      #Revisar si la estructura colapso (48)
      if danio >= 48:
          self.finished = True
          self.win      = False
          self.reason   = 'damage'
          self.running  = False
          print(f"PERDISTE Victimas salvadas: {self.victims_saved}, Muertes: {self.victims_dead}, Daño {self.damage_counter}")
          return True

      #El juego sigue
      self.finished = False
      self.win      = None
      self.reason   = None
      return False