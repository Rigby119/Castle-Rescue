# -*- coding: utf-8 -*-
"""Castle Rescue - Estrategico.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10gWUm69jRXkUsNJ3K6dDT-48qOCXDaGR

# **Castle-rescue**

### **Objetivo del sistema (Random)**
Desarrollar un sistema donde un equipo de 6 agentes llamados " Soldados " con desiciones aleatorias busquen y rescaten victimas de un castillo siendo atacado por Mountruos.

Esta versión nos servira como línea base para comparar contra la versión “estrategica”

### **Caracteristicas del sistema**

**Tablero**: 10×8 celdas contando el anillo exterior (interior 8×6); el perímetro permite entradas/salidas y el conteo de rescates.

**Vecindad**: Von Neumann (N/S/E/O), sin diagonales.

**POI en tablero:** siempre debe haber 3 en total (POI sin revelar + víctimas reveladas).

**AP**: cada héroe tiene 4 AP por turno y puede guardar AP no usados hasta 4 al finalizar, el agente puede tener un máximo de 8AP.

**Acciones principales:**
- Moverse a una casilla libre (1 AP)
- Matar monstruo (2 AP)
- Dañar a un monstruo y convertirlo en "tumba" (1 PA)
- Destruir “tumba” (1 AP)
- Abrir/cerrar puerta (1 AP)
- Revelar POI (0 AP),
- cargar víctima (mover cuesta 2 AP por celda),
- Dañar muro (2 AP)
- Romper muro completamente (4 AP)

**Ciclo de turno global**:
1. Héroes (uno por uno) Realizan acciones →
2. Dinámica del entorno (propagación/transformación de tumbas a Mounstruos, daño a muros/puertas con "invocaciones", pérdida de víctimas si aplica) →
3. Reposición de POI (si aplica), siempre debe haber 3 POI sobre el tablero.

**Condiciones de fin de la simulación**:

* Victoria al rescatar 7 victimas

* Derrota si se pierden 4 victimas o colapso por exceder umbral de daño estructural (configurable).

`Nota: Estas reglas no cambian entre baseline y eficiente; lo que cambia es cómo decide cada agente.`

**Comportamiento del agente(Random)**:

1. En el primer turno los agentes colocados en puertas entran al edificio.

    - Si el agente no tiene una entrada cercana que le permita entrar al edifício con menos de 4 AP (un turno), buscara romper o dañar una pared cercana.

2. Dentro del edificio el agente se mueve de manera aleatoria a celdas adyacentes (arriba, abajo, izquierda, derecha).

3. Si el agente encuentra una tumba en su camino la elimina (1 AP), si no tiene puntos de accion suficientes los guarda para el siguiente turno.

4. Si el agente encuentra un monstruo en su camino lo elimina (2 AP) o lo convierte en tumba (1 AP), si no tiene puntos de accion suficientes los guarda para el siguiente turno.

6. El agente puede decidir romper o dañar una pared siempre y cuando no se exceda el 60% del factor de riesgo.

7. Si el agente encuentra una puerta la abre (1 AP) , si no tiene puntos de accion suficientes los guarda para el siguiente turno.

8. Si el agente encuentra un POI lo revela (0 AP).

9. Si el POI es una falsa alarma el agente lo ignora y se sigue moviendo.

10. Si el punto de interes es una victima la carga (2 AP), si no tiene puntos de accion suficientes los guarda para el siguiente turno.

11. Si el agente esta cargando una victima, busca una salida y evacua a la victima, si no tiene puntos de accion suficientes para moverse los guarda para el siguiente turno.
"""

#!pip install numpy scipy matplotlib seaborn scikit-learn mesa==3.0 -q
#!pip install --pre mesa[viz]

# Commented out IPython magic to ensure Python compatibility.
# Requiero Mesa > 3.0.3
# Importamos las clases que se requieren para manejar los agentes (Agent) y su entorno (Model).
# Cada modelo puede contener múltiples agentes.
from mesa import Agent, Model

# Debido a que necesitamos que existe un solo agente por celda, elegimos ''SingleGrid''.
from mesa.space import SingleGrid

# Con ''RandomActivation'', hacemos que todos los agentes se activen de forma aleatoria.
# from mesa.time import RandomActivation
# Con ''BaseScheduler'', hacemos que los agentes se activen siempre en el mismo orden.
from mesa.time import BaseScheduler

# Haremos uso de ''DataCollector'' para obtener información de cada paso de la simulación.
from mesa.datacollection import DataCollector

#PARA COLORES
from matplotlib.colors import ListedColormap, BoundaryNorm

# Haremos uso de ''batch_run'' para ejecutar varias simulaciones
from mesa.batchrunner import batch_run

# matplotlib lo usaremos crear una animación de cada uno de los pasos del modelo.
# %matplotlib inline
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
plt.rcParams["animation.html"] = "jshtml"
matplotlib.rcParams['animation.embed_limit'] = 2**128

# Importamos la libreria de networkx para poder trabajar los grafos y usar A*
import networkx as netx

# Importamos los siguientes paquetes para el mejor manejo de valores numéricos.
import numpy as np
import pandas as pd
import seaborn as sns
import random

sns.set()

# Definimos otros paquetes que vamos a usar para medir el tiempo de ejecución de nuestro algoritmo.
import time
import datetime

"""# **Definir Clase Agente**"""

class SoldierAgent(Agent):
    def __init__(self, agent_id, model):
        super().__init__(model)

        self.agent_id = agent_id

        #Atributos
        self.ap = 4                       # Puntos de acción disponibles en el turno
        self.saved_ap = 0                 # Puntos de acción guardados de turnos previos
        self.carrying_victim = False      # ¿Está cargando una víctima?
        self.victims_saved = 0            # Contador local de víctimas salvadas
        self.role = None                  # Rol actual: 'rescatador_activo','rescatador_inactivo','luchador'
        self.path = []                    #Ruta planificada (cuando usemos A*/Dijkstra)
        self.target = None                # Default target ----, later PoI coord
        self.risk_threshold = 0.20        # Umbral 40% para romper/dañar paredes (Factor de riesgo)
        self.safe_play = True             # Juego Safe: evitar terminar adyacente a fuego

    def _neighbors4(self, pos):
      #Vecinos von Neumann dentro del tablero.
        x, y = pos
        W, H = self.model.grid.width, self.model.grid.height
        vecinos = [(x+1,y), #E
                   (x-1,y), #W
                   (x,y-1), #N
                   (x,y+1)] #S
        return [(nx,ny) for nx,ny in vecinos if 0 <= nx < W and 0 <= ny < H]  # Filtra dentro de límites

    #Distancia Manhattan entre dos celdas (ignorando paredes/puertas)."""
    def _manhattan(self, a, b):
        (x1,y1),(x2,y2) = a,b
        return abs(x1-x2) + abs(y1-y2)               # |dx| + |dy|

    '''#¿Al menos un vecino en FUEGO=2? (para Juego Safe)
    def _adjacent_to_fire(self, pos):
        for nx,ny in self._neighbors4(pos):          # Revisa los 4 vecinos
            if int(self.model.fire[ny, nx]) == 2:    # si alguno tiene fuego
                return True                          # Sí: peligro
        return False   '''

    def _closest_threat(self):
        width, height = self.model.grid.width, self.model.grid.height
        min_dist = float('inf')
        closest = None
        threat_type = None

        for y in range(1, height-1):
            for x in range(1, width-1):
                state = int(self.model.fire[y, x])

                if state in (1, 2):
                    dist = self.model.get_astar_weight(self.pos, (x, y))
                    if dist < min_dist:
                        min_dist = dist
                        closest = (x, y)
                        threat_type = state

        return closest, threat_type

    def _closest_exterior(self):
        min_dist = float('inf')
        closest = None

        # Recorrer todos los puntos del exterior definidos en el modelo
        for ext_pos in self.model.exterior:
            dist = self.model.get_astar_weight(self.pos, ext_pos)
            if dist < min_dist:
                min_dist = dist
                closest = ext_pos

        return closest

    # Dirección NESO desde (ax,ay) hacia (bx,by)
    def _get_direction(self, a, b):
        ax, ay = a
        bx, by = b
        if bx == ax+1 and by == ay:  return 'E'
        if bx == ax-1 and by == ay:  return 'W'
        if bx == ax   and by == ay-1: return 'N'
        if bx == ax   and by == ay+1: return 'S'
        return None

    #Identifica si un segemento esta bloqueado o no a->b Puertas y Pareds
    def _segment_blocks(self, a, b):

        d = self._get_direction(a, b)                # Dirección desde a hacia b
        ax, ay = a                                   # Coordenadas origen

        # PAREDES: 4/2 Completa o dañada bloquea, 0 Sin pared / rota =deja pasar
        pared  = int(self.model.walls[ay, ax][d])

        # PUERTAS: 0=sin puerta, 1=cerrada (bloquea), 2=abierta (deja pasar)
        puerta = int(self.model.doors[ay, ax][d])


        # Reglas: pared 2/4 bloquea; puerta 1 bloquea
        if pared != 0:                               # Si hay pared (2/4)
            return True, 'pared', pared, puerta      # Bloquea por pared

        if puerta == 1:                              # Si hay puerta cerrada
            return True, 'puerta', pared, puerta     # Bloquea por puerta

        return False, None, pared, puerta            # No bloquea

    #Abre puerta a->b si hay PA y se respeta Nuestra estrategia de Ahorro de Movimientos.
    def _open_door(self, a, b):

        if self.ap < 2:                              # Ahorro de movimientos: no abrir si no tengo >=2 PA
            print(f"[Estrategia Ahorro] No abro puerta: AP={self.ap} (necesito minimo 2).")
            return False                              # No abrimos

        # Dirección de a a b
        d = self._get_direction(a, b)
        ax, ay = a                                    # Origen
        bx, by = b                                    # Destino

        # Lado opuesto
        lado_opuesto = {'N':'S','S':'N','E':'W','W':'E'}[d]

        # Abre puerta lado origen
        self.model.doors[ay, ax][d] = 2
        # Abre puerta lado destino
        self.model.doors[by, bx][lado_opuesto] = 2

        # Abrir cuesta 1 PA
        self.ap -= 1
        print(f"[Puerta] Abrio puerta {d} en {a}->{b}. AP Actuales={self.ap}")
        return True

    #Revisar
    def _risk_ok(self):
        #El daño estructural actual está por debajo del 40%?
        return (self.model.damage_counter / 48.0) < self.risk_threshold  # True si riesgo aceptable

    #Dañar/romper pared entre a->b respetando AP y riesgo. Devuelve True si modificó.
    def _hit_or_break_wall(self, a, b):

        # Dirección de a a b
        d = self._get_direction(a, b)
        ax, ay = a                                    # Origen
        bx, by = b                                    # Destino

        lado_opuesto = {'N':'S','S':'N','E':'W','W':'E'}[d]# Lado opuesto

        # Estado pared en el segmento
        estado = int(self.model.walls[ay, ax][d])

        # Factor de riesgo > 40% no es seguro romper
        if not self._risk_ok():
            print(f"[Estrategia Riesgo] No toco la pared {a}->{b}. Daño={self.model.damage_counter}/48")
            return False

        # Si es seguro romper, la Pared completa y 4 AP: romper a 0
        if estado == 4 and self.ap >= 4:

            # Rompe lado origen
            self.model.walls[ay, ax][d] = 0
            self.model.walls[by, bx][lado_opuesto] = 0

            # +4 al contador global
            self.model.damage_counter += 4

            # Cuesta 4 AP
            self.ap -= 4
            print(f"[Pared] Rompe pared 4->0 en {a}->{b}. AP={self.ap} Daño={self.model.damage_counter}")
            return True

        # Pared completa y 2 AP: dañar a 2
        if estado == 4 and self.ap >= 2:

            #Dañar pared completa ambos lados
            self.model.walls[ay, ax][d] = 2
            self.model.walls[by, bx][lado_opuesto] = 2

            # +2 al contador
            self.model.damage_counter += 2

            # Cuesta 2 AP
            self.ap -= 2
            print(f"[Pared] Daña pared 4->2 en {a}->{b}. AP={self.ap} Daño={self.model.damage_counter}")
            return True

        # Pared dañada y 2 AP: romper a 0
        if estado == 2 and self.ap >= 2:

            #Dañar pared completa ambos lados
            self.model.walls[ay, ax][d] = 0
            self.model.walls[by, bx][lado_opuesto] = 0

            # +2 al contador
            self.model.damage_counter += 2

            # Cuesta 2 AP
            self.ap -= 2
            print(f"[Pared] Rompe pared 2->0 en {a}->{b}. AP={self.ap} Daño={self.model.damage_counter}")
            return True

        print(f"[Pared] No modificada pared {estado} en {a}->{b}. AP={self.ap}")
        return False

    #Ataque sencillo a monstruo/tumba en 'target' si hay AP
    def _fight_monster_or_tomb(self, target):

        # Coordenadas de la casilla en ruta
        tx, ty = target

        #Estado de la casilla 2=monstruo, 1=tumba, 0=vacío
        state = int(self.model.fire[ty, tx])

        # Monstruo: si tengo 2 AP, mato el mountruo
        if state == 2 and self.ap >= 2:
            # Deja celda vacía
            self.model.fire[ty, tx] = 0

            #Cuesta 2
            self.ap -= 2
            print(f"[Lucha] Mato un monstruo en {target}. AP={self.ap}")
            return True

        # Es un Mounstruo y solo 1 AP: convertir a tumba
        if state == 2 and self.ap == 1:

            # Deja tumba
            self.model.fire[ty, tx] = 1
            # Cuesta 1
            self.ap -= 1
            print(f"[Lucha] Convertio monstruo a tumba en {target}. AP={self.ap}")
            return True

        # Tumba: destruir si hay 1 AP
        if state == 1 and self.ap >= 1:

            # Limpia celda
            self.model.fire[ty, tx] = 0
            # Cuesta 1
            self.ap -= 1
            print(f"[Lucha] Destruyo tumba en {target}. AP={self.ap}")
            return True

        return False                                   # No se pudo atacar


    #Mover agente al destino (dest) si la celda está libre y hay AP suficientes
    def _move_to(self, dest, cost=1):

        # si no tengo PAs suficientes no me muevo
        if self.ap < cost:
            return False
        #Si la celda no esta vacia no me muevo
        if not self.model.grid.is_cell_empty(dest):
            return False                               # Ocupada: no me muevo

        #Mueve al agente
        self.model.grid.move_agent(self, dest)

        # PA (1 normal, 2 si carga víctima)
        self.ap -= cost
        print(f"[Move] Me moví a {dest}. AP={self.ap}")
        return True                                    # Movimiento realizado


     # ---------- Juego Safe corregido ----------
     #Si algun vecino del destino tien fuego y ese segmento no esta bloqueado evita moverse al fuego
    def _unsafe_to_end_at(self, dest):

          for fx, fy in self._neighbors4(dest):
              if int(self.model.fire[fy, fx]) == 2:
                  bloquea, _, _, _ = self._segment_blocks(dest, (fx, fy))
                  if not bloquea:
                      return True
          return False

    # ----------------- Búsquedas simples / objetivos -----------------

    #Devuelve el POI más cercano (estado 1 o 3)
    def _closest_poi(self):

        W, H = self.model.grid.width, self.model.grid.height

        # Lista de POIs candidatos
        pois = []
        for y in range(1, H-1):
            for x in range(1, W-1):
                if int(self.model.pois[y, x]) in (1, 3):       # 1=no revelado, 3=victim revelada
                    pois.append((x, y))                        # Agrega coordenada
        if not pois:                               # ¿No hay?
            return None                            # No objetivo


        # Selecciona por Manhattan mínima (ignora paredes; A* será después)
        # Posición actual
        pos = self.pos
        target = min(pois, key=lambda p: self._manhattan(pos, p))
        return target                               # Devuelve objetivo

    #Propone un vecino que acerque a 'target' por Manhattan
    def _greedy_step_towards(self, target):

        # Sin objetivo, no hay paso
        if not target:
            return None

        # Origen
        x, y = self.pos

        # Destino
        tx, ty = target
        # Prioridad: mover en eje X si reduce distancia, si no, en Y
        cand = []                                   # Candidatos ordenados por “acerca”
        if tx > x: cand.append((x+1, y))            # Intento hacia Este
        if tx < x: cand.append((x-1, y))            # Intento hacia Oeste
        if ty < y: cand.append((x, y-1))            # Intento hacia Norte
        if ty > y: cand.append((x, y+1))            # Intento hacia Sur


        # Filtramos a vecinos válidos del grid
        neighs = self._neighbors4((x,y))            # Vecinos válidos
        cand = [c for c in cand if c in neighs]     # Solo candidatos dentro del grid
        return cand[0] if cand else None            # Devuelve el primero que acerque

    # *********************** COMPORTAMIENTOS **********************************

    # -------- Rescatador Inactivo (ir a POI, revelar y, si procede, recoger) --------
    def _do_rescatador_inactivo(self):

        #Estrategia ETAPA 3 DE MI MAQUINA DE ESTADOS: ir al POI más cercano y operar ahí."""
        if not self.target_poi:
            # Si por alguna razón no tiene POI asignado, busca el más cercano
            target = self._closest_poi()
        else:
            target = self.target_poi

        if not target:                              # ¿No hay?
            print("[Inactivo] No hay POIs en tablero.")
            return

        print(f"[Inactivo] Objetivo POI: {target}") # Traza del objetivo

        path = self.model.get_astar_path(self.pos, target)
        
        path_index = 1

        # Mientras tenga PA, avanzo hacia el objetivo y opero
        # Consume turno hasta agotar PA
        while self.ap > 0:
            # 1) ¿Ya estoy en el POI?
            if self.pos == target:
                tx, ty = target
                state = int(self.model.pois[ty, tx])


                #Revelar (0 PA)
                if state == 1:
                    # Asegura tipo si aún no está asignado
                    if int(self.model.poi_type[ty, tx]) == 0:
                        # Lo revela
                        self.model.random_POI()

                    #Asigna el muevo revelado
                    revealed = int(self.model.poi_type[ty, tx])
                    self.model.pois[ty, tx] = revealed
                    print(f"[Inactivo] Revelé POI en {target}: tipo={revealed} (0 PA)")

                    if revealed == 2:
                        # Falsa alarma → se elimina
                        self.model.pois[ty, tx] = 0
                        self.model.assignRoles()
                        break

                # Recoger víctima (0 PA)
                if int(self.model.pois[ty, tx]) == 3 and not self.carrying_victim:
                    self.carrying_victim = True
                    self.model.pois[ty, tx] = 0
                    print(f"[Inactivo] Recogí víctima en {target} (0 PA).")
                    self.model.assignRoles()
                    break  # pasará a rescatador activo en el siguiente ciclo

                break  # nada más que hacer en esta celda

            # Verificar si tenemos más pasos en la ruta
            if path_index >= len(path):
                print("[Inactivo] Llegué al final del path sin alcanzar objetivo, Weirdd...")
                break
            
            next_step = path[path_index]

            # Verificar si el siguiente paso está bloqueado
            bloquea, tipo, pared, puerta = self._segment_blocks(self.pos, next_step)
            
            if bloquea:
                if tipo == 'puerta':                  # Puerta cerrada
                    if not self._open_door(self.pos, next_step):  # Intento abrir respetando “ahorro”
                        break                          # No abrí → fin de intento este turno
                    new_path = self.model.get_astar_path(self.pos, target)
                    path = new_path
                    path_index = 1
                    continue
                else:                                 # Pared (2 o 4)
                    if not self._hit_or_break_wall(self.pos, next_step):  # Intento dañar/romper con riesgo
                        break                          # No dañar tocar pared → fin de intento
                    # Si la pared quedó en 0 puedo reintentar el paso en el siguiente ciclo
                    new_path = self.model.get_astar_path(self.pos, target)
                    path = new_path
                    path_index = 1
                    continue

            # Si no bloquea, reviso si hay monstruo/tumba en la celda destino
            tx, ty = next_step                              # Coordenadas destino
            cell_state = int(self.model.fire[ty, tx])  # Fuego/tumba en destino
            if cell_state in (1, 2):                   # Hay tumba o monstruo
                if not self._fight_monster_or_tomb(next_step):  # Intento pelear
                    break                              # No pude pelear → detengo
                continue                               # Si peleé, vuelvo al loop (quizá ya quedó libre)

            # --- Juego Safe corregido ---
            move_cost = 2 if self.carrying_victim else 1

            # Aplicar regla de juego seguro
            if self.ap < 3 and self._unsafe_to_end_at(next_step):
                print(f"[Safe] Evito {next_step} con AP={self.ap}")
                break
            
            if not self._move_to(next_step, cost=move_cost):
                break
            
            path_index += 1

    # -------- Rescatador Activo (stub) --------
    def _do_rescatador_activo(self):
        #Lleva a la víctima al exterior (dejarla no cuesta PA).
        #Respeta:
           #Ahorro de movimientos al abrir puertas (_open_door).
           #Factor de riesgo antes de tocar paredes (_hit_or_break_wall).
           #Juego Safe antes de dar el paso final (_safe_to_end_at).

        if not self.carrying_victim:
            print("[Activo] No tengo víctima → me comporto como inactivo este turno.")
            return self._do_rescatador_inactivo()

        target = self._closest_exterior()
        print(f"[Activo] Objetivo exterior más cercano: {target}")

        self.model.update_graph_weights(carrying_victim=True)

        path = self.model.get_astar_path(self.pos, target)

        path_index  = 1

        while self.ap > 0:
            #Ya estoy en la salida Dejo víctima y termino
            if self.pos in self.model.exterior:
                self.carrying_victim = False
                self.victims_saved += 1
                print(f"[Activo] Dejé víctima en {self.pos}. Víctimas salvadas por este agente: {self.victims_saved}")
                self.model.assignRoles()
                break

            if path_index >= len(path):
                print("[Activo] Sin más pasos en ruta")
                break
            
            next_step = path[path_index]

            # Manejar bloqueos
            bloquea, tipo, pared, puerta = self._segment_blocks(self.pos, next_step)
            if bloquea:
                if tipo == 'puerta':
                    if not self._open_door(self.pos, next_step):
                        break
                    # Recalcular con víctima
                    self.model.update_graph_weights(carrying_victim=True)
                    path = self.model.get_astar_path(self.pos, target)
                    path_index = 1
                    continue
                else:  # Pared
                    if not self._hit_or_break_wall(self.pos, next_step):
                        break
                    # Recalcular con víctima
                    self.model.update_graph_weights(carrying_victim=True)
                    path = self.model.get_astar_path(self.pos, target)
                    path_index = 1
                    continue

            # Si la celda destino tiene monstruo/tumba, intenta limpiar primero
            tx, ty = next_step
            state = int(self.model.fire[ty, tx])
            if state in (1, 2):
                if not self._fight_monster_or_tomb(next_step):
                    break
                continue  # limpio: reintento el paso
            
            # Moverse (cuesta 2 AP con víctima)
            if self._unsafe_to_end_at(next_step) and self.ap < 5:
                print(f"[Safe] Evito {next_step} cargando víctima")
                break
            
            if not self._move_to(next_step, cost=2):
                break
            
            path_index += 1

    # -------- Luchador (stub) --------
    def _do_luchador(self):
        """Luchador:
        Busca la amenaza más cercana (fuego 2; si no hay, tumba 1).
        NUNCA rompe/daña paredes.
        Puede abrir puertas solo si tiene >=2 PA (Ahorro).
        Si le quedarán <3 PA, evita terminar en una casilla con fuego adyacente sin bloqueo (Juego Safe).
        """

        # Encontrar la amenaza más cercana
        target, ttype = self._closest_threat()
        if not target:
            print("[Luchador] No hay amenazas (fuego/tumbas).")
            return

        print(f"[Luchador] Objetivo: {target} (tipo={ttype})")

        path = self.model.get_astar_path(self.pos, target)
        indexRoute = 1

        # Mientras tenga PA, avanzo hacia el objetivo y opero
        while self.ap > 0:
            # 1) ¿Ya estoy en la amenaza?
            if self.pos == target:
                tx, ty = target
                state = int(self.model.fire[ty, tx])

                # Si ya no hay amenaza aquí, buscar otra
                if state not in (1, 2):
                    target, ttype = self._closest_threat()
                    if not target:
                        print("[Luchador] No hay más amenazas.")
                        break
                    print(f"[Luchador] Nueva amenaza: {target}")
                    path = self.model.get_astar_path(self.pos, target)
                    indexRoute = 1
                    continue

                # Atacar la amenaza
                if self._fight_monster_or_tomb(target):
                    print(f"[Luchador] Eliminé amenaza en {target}")
                    # Buscar nueva amenaza para continuar
                    target, ttype = self._closest_threat()
                    if not target:
                        print("[Luchador] No hay más amenazas.")
                        break
                    print(f"[Luchador] Nueva amenaza: {target}")
                    path = self.model.get_astar_path(self.pos, target)
                    indexRoute = 1
                    continue
                else:
                    # No pude atacar (sin AP)
                    break

            if indexRoute >= len(path):
                print("[Luchador] Llegué al final del path sin encontrar la amenaza.")
                break

            step = path[indexRoute]

            # 3) ¿El segmento bloquea?
            bloquea, tipo, pared, puerta = self._segment_blocks(self.pos, step)
            if bloquea:
                if tipo == 'puerta':
                    # Intentar abrir puerta (respetando estrategia de ahorro)
                    if not self._open_door(self.pos, step):
                        break  # No pude abrir
                    continue  # Puerta abierta, reintento en siguiente iteración
                else:  # Es pared
                    # El luchador NUNCA rompe paredes
                    print(f"[Luchador] Bloqueado por pared hacia {step}")
                    break

            # 4) Si hay monstruo/tumba en destino, limpiar primero
            tx, ty = step
            cell_state = int(self.model.fire[ty, tx])
            if cell_state in (1, 2):
                if not self._fight_monster_or_tomb(step):
                    break  # No pude limpiar
                continue  # Limpié, reintento el movimiento

            # 5) Aplicar regla de Juego Safe
            move_cost = 1  # El luchador no carga víctima
            if self.ap < 3 and self._unsafe_to_end_at(step):
                print(f"[Safe] Evito {step} con AP={self.ap} (fuego adyacente sin bloqueo)")
                break

            # 6) Intentar moverse
            if not self.model.grid.is_cell_empty(step):
                break  # Celda ocupada

            if not self._move_to(step, cost=move_cost):
                break  # No pude moverme (sin AP)

            # Avanzar al siguiente punto del path
            indexRoute += 1

            # Continúo el bucle para seguir acercándome o atacar

    def step(self):
        # turno del agente estratégico

        # Si el juego ya terminó, no hago nada
        if self.model.finish_game():
            return

        # Recuperar PA guardados (máx 8 en total)

        # Recupera AP guardados sin pasar de 8
        self.ap = min(self.ap + self.saved_ap, 8)
        self.saved_ap = 0

        print(f"\n[Turno] Agente {self.unique_id} en {self.pos} con AP={self.ap}")  # Traza de inicio

        # Si ya estoy cargando víctima, el rol es forzosamente “activo”
        if self.carrying_victim:
            self.role = 'rescatador_activo'

        print(f"[Rol] Rol decidido: {self.role}")

        # Ejecuta comportamiento según rol
        if self.role == 'rescatador_activo':
            self._do_rescatador_activo()             # Comportamiento activo
        elif self.role == 'rescatador_inactivo':
            self._do_rescatador_inactivo()           # Comportamiento inactivo
        else:
            self._do_luchador()                      # Comportamiento luchador

        # Guarda AP no usados para el próximo turno
        self.saved_ap = self.ap                      # Lo que quede, se guarda
        self.ap = 4                                  # Resetea AP base del siguiente turno

        # Ejecuta dinámicas del entorno al finalizar el turno del agente
        self.model.propagacion_del_fuego()           # Propagación/Explosiones del fuego
        self.model.agentes_incendiados()             # Reubicar agentes incendiados
        self.model.posicionamiento_POI()             # Reposición de POIs
        self.model.poi_incenciados()                 # POIs que se quemaron este paso

"""# **Creacion clase Modelo (Entorno)**

**Entorno**

Grid 10×8 con: celdas interiores/exteriores

 muros:
 * 0 = Sin daño
 * 1 = fracturado
 * 2 = destruido

 puertas:
 * 0 = cerrada
 * 1 = abierta

**Entidades:**
1. Soldados
2. POI (víctimas/falsas alarmas),
3. monstruos (humo/fuego).

**Variables globales: **
1. víctimas rescatadas/perdidas
2. daño estructural acumulado,
3. turno/step,
4. POI visibles/ocultos.

**Dinámica del entorno:** después de acciones de los soldados, propagación/transformación de humo/monstruo (eventos que pueden dañar muros/puertas y ocasionar pérdida de víctimas en celdas afectadas); reposición de POI hasta 3 en tablero; verificación de condiciones de fin.

**Inicialización:**
1. cargar mapa (muros/puertas/entradas
2. colocar héroes en exterior válido
3. asegurar 3 POI en tablero
4. ubicar monstruos iniciales.

**DataCollector:**

Modelo (por step): Victimas rescatadas/perdidas, daño acumulado, numero de steps

Agente (por step ) : AP usados/guardados, víctimas rescatadas, steps, eficiencia

## **Crear matriz "visualizable"**
"""

# Mapa de categorías:
# 0 = vacío
# 1 = humo
# 2 = fuego
# 3 = POI sin revelar
# 4 = POI víctima
# 5 = POI falsa alarma
# 6 = agente

def get_grid(model):
    H, W = model.grid.height, model.grid.width
    M = np.zeros((H, W), dtype=np.int8)

    # Capa fuego/humo
    M[model.fire == 1] = 1
    M[model.fire == 2] = 2

    # Capa POIs (encima de fuego/humo)
    M[model.pois == 1] = 3
    M[model.pois == 3] = 4
    M[model.pois == 2] = 5

    # Capa agentes (encima de todo)
    for ag in model.schedule.agents:
        x, y = ag.pos
        M[y, x] = 6

    return M

'''#Llenamos la grid con comida
def get_grid(model):
    grid = np.zeros((model.grid.height, model.grid.width))
    grid += model.fire
    grid += model.pois
    for content, (x,y) in model.grid.coord_iter():
        if isinstance(content, SoldierAgent):
            grid[y][x] = 3
    return grid'''

class CastleRescueModel(Model):

    def __init__(self, width = 10 , height = 8, agents = 6): #Columnas(x), filas(y)
        super().__init__()

        #Grid solo para un soldado por celda y sin grid toroidal
        self.grid = SingleGrid(width, height, torus=False)#grid no toroidal

        #Por ahora el posicionamiento de agentes sera Random
        #Pero debemos cambiarlo
        self.schedule = BaseScheduler(self)

        # ---------------------------- Grafo ----------------------------

        self.Castle_graph = netx.Graph()

        for index in range(width * height):
            x = index % width
            y = index // width

            coord = (x, y)

            self.Castle_graph.add_node(coord)

        for index in range(width * height):
            x = index % width
            y = index // width

            # Coordenadas N, S, E, W
            directions = [True, True, True, True]
            locations = [(0, 1),(0, -1),(1, 0),(-1, 0)]

            if y == 0:
                directions[0] = False
            if y == height-1:
                directions[1] = False
            if x == width-1:
                directions[2] = False
            if x == 0:
                directions[3] = False

            origin = (x, y)

            count = 0
            for dir in directions:
                if dir:
                    dx, dy = locations[count]
                    destiny = (x + dx, y + dy)
                    self.Castle_graph.add_edge(origin, destiny, weight = 0)
                count += 1

        # -----------------Exterior del edificio-----------------------------------------

        self.exterior = [
            (0,0), (1,0), (2,0), (3,0), (4,0), (5,0), (6,0), (7,0), (8,0), (9,0),
            (0,7), (1,7), (2,7), (3,7), (4,7), (5,7), (6,7), (7,7), (8,7), (9,7),
            (0,1), (0,2), (0,3), (0,4), (0,5), (0,6),
            (9,1), (9,2), (9,3), (9,4), (9,5), (9,6)
        ]

        # ------------------Matriz Fuego / Humo------------------------------------------
        #Valor de la celda de la matriz FUEGO:
        #     0 = celda interior vacía (sin humo ni fuego)
        #     1 = humo
        #     2 = fuego


        # Crear Mapa con recursos de Mounstruo/Tumba
        # Los arreglos se indexan como [fila, columna]
        self.fire = np.zeros((height, width))#0/1/2 Important H y W para buena impresion

        #Lista de posicion de los primeros fuegos al iniciar la partida
        Pos_inicial_monsters = [
            (2, 2), (3, 2), (2, 3), (3, 3), (4, 3),
            (5, 3), (4, 4), (6, 5), (7, 5), (6, 6)
        ]

        for (x, y) in Pos_inicial_monsters:
        #Para checar el rango de la matriz por si la lista inicial cambia
        #if 0 <= x < width and 0 <= y < height:
            self.fire[y][x] = 2 # fila= y columna=x

        self.current_agent_idx = 0

    # ------------------Matriz Puntos de Interes------------------------------------------
    #Valor de la celda de la matriz POI:
        #     0 = Vacío
        #     1 = POI sin rebelar
        #     2 = POI Falsa Alarma
        #     3 = POI con Victima

        self.pois = np.zeros((height, width))

        #Fer
        self.poi_type = np.zeros((height, width))

        self.victims_placed = 0
        self.false_alarms_placed = 0
        self.max_victims = 10
        self.victims = 10
        self.victims_saved = 0
        self.max_false_alarms = 5
        self.false_alarms = 5
        self.victims_dead = 0

        #Lista de posicion de los primeros fuegos al iniciar la partida
        Pos_inicial_POI = [
            (4, 2), (1, 5), (8, 5),
        ]

        for (x, y) in Pos_inicial_POI:
        #Para checar el rango de la matriz por si la lista inicial cambia
        #if 0 <= x < width and 0 <= y < height:
            self.pois[y][x] = 1 # fila= y columna=x


        self.random_POI()

    # ------------------Matriz de objetos Puertas----------------------------------------
        #Valor de la celda de la matriz Puertas:
        #     0 = Sin Puerta
        #     1 = Cerrada
        #     2 = Abierta

        self.doors = np.empty((height, width),dtype=object)
        #Para inicializar todo sin puertas
        for y in range(height):
            for x in range(width):
                self.doors[y][x] = {'N': 0, 'E': 0, 'S': 0, 'W': 0}

        #Para tambien actualizar la misma puerta en el vecino
        vecinos = {'N': (0, -1), 'S': (0, +1), 'E': (1, 0), 'W': (-1, 0)}
        lado_op   = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}

        # Formato: (x, y, lado, estado)
        Puertas_iniciales = [ (1, 3, 'W', 2), (3,6,"S",2), (8,4,"E",2),
        (6, 1,"N",2), (2, 3,"E",1), (3, 1,"E",1), (5, 2,"E",1), (6, 4,"E",1),
        (5, 6,"E",1), (7, 6,"E",1), (8, 2,"S",1), (4, 4,"S",1)
        ]

        # Colocación y sincronización automática con la celda vecina
        for (x, y, d, state) in Puertas_iniciales:
                self.doors[y, x][d] = state
                dx, dy = vecinos[d]
                nx, ny = x + dx, y + dy
                if 0 <= nx < width and 0 <= ny < height:
                    self.doors[ny, nx][lado_op[d]] = state


    # ------------------Matriz de objetos Paredes----------------------------------------
        #Valor de la celda de la matriz Paredes:
        #     0 = Pared Rota
        #     2 = Pared Dañada
        #     4 = Pared Completa

        #VARIABLE GLOBAL DE DAÑO
        self.damage_counter = 0

        self.walls = np.empty((height, width),dtype=object)
        #Para inicializar todo sin puertas
        for y in range(height):
            for x in range(width):
                self.walls[y][x] = {'N': 0, 'E': 0, 'S': 0, 'W': 0}

        #Para tambien actualizar la misma puerta en el vecino
        #vecinos = {'N': (0, 1), 'S': (0, -1), 'E': (1, 0), 'W': (-1, 0)}
        #lado_op   = {'N': 'S', 'S': 'N', 'E': 'W', 'W': 'E'}

        # Formato: (x, y, lado, estado)
        Walls_iniciales = [ (1, 1, 'W', 4), (1, 1, 'N', 4), (1, 2, 'W', 4),
        (1, 4, 'W', 4), (1, 4, 'S', 4), (1, 5, 'W', 4), (1, 6, 'W', 4),
        (1, 6, 'S', 4), (2, 1, 'N', 4), (2, 4, 'E', 4), (2, 4, 'S', 4),
        (2, 6, 'S', 4), (3, 1, 'N', 4), (3, 2, 'E', 4), (3, 2, 'S', 4),
        (3, 4, 'S', 4), (4, 1, 'N', 4), (4, 2, 'S', 4), (4, 6, 'S', 4),
        (5, 1, 'N', 4), (5, 1, 'E', 4), (5, 2, 'S', 4), (5, 4, 'S', 4),
        (5, 5, 'E', 4), (5, 6, 'S', 4), (6, 2, 'S', 4), (6, 3, 'E', 4),
        (6, 4, 'S', 4), (6, 6, 'S', 4), (7, 1, 'N', 4), (7, 2, 'S', 4),
        (7, 4, 'S', 4), (7, 5, 'E', 4), (7, 6, 'S', 4), (8, 1, 'N', 4),
        (8, 1, 'E', 4), (8, 2, 'E', 4), (8, 3, 'E', 4), (8, 4, 'S', 4),
        (8, 5, 'E', 4), (8, 6, 'E', 4), (8, 6, 'S', 4)
        ]

        # Colocación y sincronización automática con la celda vecina
        for (x, y, d, state) in Walls_iniciales:
                self.walls[y, x][d] = state
                dx, dy = vecinos[d]
                nx, ny = x + dx, y + dy
                if 0 <= nx < width and 0 <= ny < height:
                    self.walls[ny, nx][lado_op[d]] = state

        # --- Inicializar agentes ---

        # Psiciones de reubicación
        pos_agent = [(9,5),(0,5),(0, 3), (3, 7), (9, 4), (6, 0)]

        for i, pos in enumerate(pos_agent):
            agent = SoldierAgent(i + 1, self)     # crea agente i
            self.schedule.add(agent)       # lo añade al scheduler
            self.grid.place_agent(agent, pos)  # lo coloca exactamente en pos

        self.assignRoles()

        self.datacollector = DataCollector(
            model_reporters={
                "Grid": get_grid,
                "Steps": lambda model : model.steps
            },
            agent_reporters={
                "Victims_saved": lambda agent : agent.victims_saved,
                #"Refills:": lambda agent: agent.agent_in_base
            }
        )

    #FUERA DEL CONSTRUCTOR ABAJO

    # Heuristica de A*
    def manhattan(self, a, b):
        (x1, y1) , (x2, y2) = a,b
        return abs(x1 - x2) + abs(y1 - y2)

    # Función para actualizar pesos
    def update_graph_weights(self, carrying_victim = False):
        # Definir costos
        base_cost = 1
        carry_cost = 2

        risk_factor = self.damage_counter / 48

        # Diccionario de cardinalidad
        directions = {
            'N': (0, -1),
            'S': (0, 1),
            'E': (1, 0),
            'W': (-1, 0)
        }

        width, height = self.grid.width, self.grid.height

        self.Castle_graph.clear_edges()

        for y in range(height):
            for x in range(width):
                origin = (x, y)

                for direction, (dx, dy) in directions.items():
                    destiny = (x + dx, y + dy)

                    # Limit check
                    if not (0 <= destiny[0] < width and 0 <= destiny[1] < height):
                        continue
                    
                    edge_cost = carry_cost if carrying_victim else base_cost

                    # Check walls
                    wall_state = int(self.walls[y, x][direction])
                    if wall_state == 4:  # Pared completa
                        if risk_factor >= 0.20:
                            edge_cost += 1000
                        else:
                            edge_cost += 4
                    elif wall_state == 2:  # Pared dañada
                        if risk_factor >= 0.20:
                            edge_cost += 1000
                        else:
                            edge_cost += 2

                    # Check doors
                    door_state = int(self.doors[y, x][direction])
                    if door_state == 1:  # Closed door
                        edge_cost += 1

                    dest_x, dest_y = destiny

                    fire_state = int(self.fire[dest_y, dest_x])
                    if fire_state == 1:
                        edge_cost += 1
                    elif fire_state == 2:
                        edge_cost += 2

                    self.Castle_graph.add_edge(origin, destiny, weight=edge_cost)

    def get_astar_path(self, origin, destiny):
        return netx.astar_path(self.Castle_graph, origin, destiny, heuristic=self.manhattan, weight="weight")

    def get_astar_weight(self, origin, destiny):
        return netx.astar_path_length(self.Castle_graph, origin, destiny, heuristic=self.manhattan, weight="weight")

    def assignRoles(self):
        """Asigna roles a los agentes basándose en distancias A* reales"""

        width, height = self.grid.width, self.grid.height

        poiList = []
        for y in range(height):
            for x in range(width):
                if self.pois[y, x] == 1:
                    poiList.append((x, y))

        agents_list = list(self.schedule.agents)

        self.update_graph_weights(carrying_victim = False)

        agent_poi_distances = []

        for agent in agents_list:
            distances = []
            for poi in poiList:
                distance = self.get_astar_weight(agent.pos, poi)
                distances.append(distance)
            agent_poi_distances.append(distances)

        assigned_pois = set()
        assigned_agents = set()

        # Limpiar POIs asignados anteriormente
        for agent in agents_list:
            agent.target_poi = None
            agent.role = None

        for _ in range(3):
            min_dist = float('inf')
            best_agent_idx = None
            best_poi_idx = None

            # Buscar la menor distancia entre agentes y POIs no asignados
            for agent_idx, distances in enumerate(agent_poi_distances):
                if agent_idx in assigned_agents:
                    continue
                for poi_idx, dist in enumerate(distances):
                    if poi_idx in assigned_pois:
                        continue
                    if dist < min_dist:
                        min_dist = dist
                        best_agent_idx = agent_idx
                        best_poi_idx = poi_idx

            # Asignar el mejor par encontrado
            if best_agent_idx is not None:
                agent = agents_list[best_agent_idx]
                poi = poiList[best_poi_idx]

                agent.role = 'rescatador_inactivo'
                agent.target_poi = poi

                assigned_agents.add(best_agent_idx)
                assigned_pois.add(best_poi_idx)

                print(f"Agente {agent.unique_id} asignado a POI {poi} (distancia: {min_dist})")

        # Los agentes no asignados serán luchadores
        for i, agent in enumerate(agents_list):
            if i not in assigned_agents:
                agent.role = 'luchador'
                agent.target_poi = None  # Los luchadores no tienen POI asignado

    #Posicionamiento (provicional) de los agentes SEGUN YO NO ES NECESARIO ASI
    def random_agent_position(self, width, height):
        side = self.random.randint(0, 3)
        if side == 0:  # top
            x = self.random.randint(0, width-1)
            y = 0
        elif side == 1:  # bottom
            x = self.random.randint(0, width-1)
            y = height-1
        elif side == 2:  # left
            x = 0
            y = self.random.randint(0, height-1)
        else:  # right
            x = width-1
            y = self.random.randint(0, height-1)
        return (x, y)
    
    # ------- Funciones del model------------

    #--------Funcion para fuegos

    #def InvocaciondeMounstruos

    #Funcion para cordenada aleatoria
    def _coord_aleatoria(self):
        x = random.randint(1,8)
        y = random.randint(1,6)
        return (x, y)

    def propagacion_del_fuego(self):
        #Elige una celda (objetivo) y ejecuta la transición según su estado:
            #0 → _fuego_estado_0
            #1 → _fuego_estado_1
            #2 → _fuego_estado_2_explosion (stub por ahora)
        print("\n\n<<<<<<< FUNCION DE PROP FUEGO >>>>>>>>")
        # 1) Elegir coordenada Objetivo

        x, y = self._coord_aleatoria()

        print(f"Objetivo: {(x, y)}")

        #state = self.fire[y, x]
        #print(f"State: {state}")

        estado = int(self.fire[y, x])

        print(f"Estado: {estado}")

        if estado == 0:
            return self._fuego_estado_0(y, x)
        elif estado == 1:
            return self._fuego_estado_1(y, x)
        else:  # estado == 2
            return self._fuego_estado_2_explosion(y, x)

    def _fuego_estado_0(self, y, x):
      print("\n\n<<<<<<< FUNCION DE FUEGO 0 >>>>>>>>")
      #Lógica:
        #Si NO hay vecinos con 2 -> la celda pasa a 1 (humo).
        #Si SÍ hay vecinos con 2:
          #Para cada vecino con 2:
            #Si hay PARED COMPLETA (=4) o dañada entre ambos -> bloquea -> seguimos revisando.
            #Si hay Puerta Cerrada (=1) entre ambos -> bloquea -> seguimos revisando.
            #Si pared esta ROTA (=0) -> enciende (2).
            #Si NO hay pared (valor 0 en el dict) -> enciende (2)
            #Revisamos si hay humos por prender adyacente al fuego que creamos y revisamos la cadena.
          #Si TODOS los vecinos en 2 estaban bloqueados por pared completa -> humo (1).

      #Revisar Vecinos
      vecinos = [
          (x+1, y),  # Este
          (x-1, y),  # Oeste
          (x, y-1),  # Norte
          (x, y+1),  # Sur
      ]

      # #Filtrar vecinos que están en FUEGO
      vecinos_en_fuego = [(nx, ny) for (nx, ny) in vecinos if int(self.fire[ny, nx]) == 2]

      #Sin vecinos en fuego -> HUMO (=1)
      if not vecinos_en_fuego:
          self.fire[y, x] = 1
          print(f"objetivo: {(x, y)} antes: {0} despues: {1} motivo: sin_vecino_en_fuego")
          return

      #Hay vecinos en fuego: por defecto HUMO, pero si alguno permite paso -> FUEGO

      self.fire[y, x] = 1        # valor por defecto si TODOS bloquean
      bloqueados_todos = True    # bandera: asumimos bloqueo total hasta demostrar lo contrario

      #saber de donde vienen los fuegos, para buscar la pared o puerta
      def dir_from_to(x0, y0, x1, y1):
          if x1 == x0+1 and y1 == y0:   return 'E'
          if x1 == x0-1 and y1 == y0:   return 'W'
          if x1 == x0   and y1 == y0-1: return 'N'
          if x1 == x0   and y1 == y0+1: return 'S'

      #Para cada Vecino
      for (nx, ny) in vecinos_en_fuego:
          d = dir_from_to(x, y, nx, ny)  #Direccion del vecino N, E, W, S

          #Leemos pared y puerta en el segmento (y,x) --d--> (ny,nx)

          # PAREDES: 4/2 Completa o dañada bloquea, 0 Sin pared / rota =deja pasar
          estado_pared  = int(self.walls[y, x].get(d, 0))
          print(f"pared: {self.walls[y, x]}")

          # PUERTAS: 0=sin puerta, 1=cerrada (bloquea), 2=abierta (deja pasar)
          estado_puerta = int(self.doors[y, x].get(d, 0))
          print(f"puerta: {self.doors[y, x]}")

          #Variable Bandera interna de bloqueo
          bloquea = False

          if estado_pared != 0:
              bloquea = True
          else:
              if estado_puerta == 1:
                  bloquea = True
              else:
                  bloquea = False # pared rota o sin pared y puerta abierta/sin puerta

          if bloquea == False:
              # Si NO bloquea, con UNO que deje pasar, esta celda se enciende
              self.fire[y, x] = 2
              bloqueados_todos = False

              # ──FASE NUEVA Propaga a HUMO=1 adyacente alcanzable ---BFS---

              # Guardamos lista de celdas encendidas en este paso
              encendidos = [(x, y)]

              # Usamos una cola para recorrer por casillas
              por_visitar = [(x, y)]

              #REVISAR SI SE TIENE QUE PONER SET
              visitados = {(x, y)}

              W, H = self.grid.width, self.grid.height

              def vecinos_lim(cx, cy):
                  nuevosVecinos = [(cx+1, cy), (cx-1, cy), (cx, cy-1), (cx, cy+1)]
                  return [(vx, vy) for (vx, vy) in nuevosVecinos if 0 <= vx < W and 0 <= vy < H]

              # Recorremos la cola de humos, expandiendo el fuego si no hay bloqueo
              while por_visitar:
                  # sacamos el siguiente origen de casilla
                  cx, cy = por_visitar.pop(0)

                  # miramos los 4 vecinos de esa casilla
                  for vx, vy in vecinos_lim(cx, cy):

                      # si ya revisamos esta casilla
                      if (vx, vy) in visitados:
                          continue

                      # Solo nos interesan vecinos que actualmente estén en HUMO (=1)
                      if int(self.fire[vy, vx]) != 1:
                          continue

                      # Revisar bloqueo en el segmento (cx,cy) --d--> (nx,ny)
                      d2 = dir_from_to(cx, cy, vx, vy)
                      pared  = int(self.walls[cy, cx][d2]) # 4/2 bloquea; 0 no bloquea
                      print(f"pared: {self.walls[y, x]}")

                      puerta = int(self.doors[cy, cx][d2]) # 1 bloquea; 0/2 no bloquea
                      print(f"puerta: {self.doors[y, x]}")

                      # Bloquea si pared != 0 (o sea 2 ó 4) o puerta cerrada (=1)
                      #Variable Bandera interna de bloqueo
                      bloquea = False

                      if estado_pared != 0:
                          bloquea = True
                      else:
                          if estado_puerta == 1:
                              bloquea = True
                          else:
                              bloquea = False # pared rota o sin pared y puerta abierta/sin puerta

                      if bloquea == True:
                          continue  # no se expande el fuego

                      # Si NO bloquea el humos se convierte en FUEGO
                      self.fire[vy, vx] = 2
                      encendidos.append((nx, ny))
                      visitados.add((vx, vy))

                      #Y ahora este nuevo fuego puede encender a sus HUMOS vecinos (se va a la cola)
                      por_visitar.append((vx, vy))

              # Una vez encendida y propagada, ya no hace falta revisar otros vecinos
              break

      # Salidas para revisar
      if bloqueados_todos:
          print(f"Origen: {(x, y)}\nAntes: {0}\nDespues: {1}\nMotivo: Bloqueado por pared/puerta")

      else:
          print(f"Objetivo: {(x, y)}\nAntes: {0}\nDespues: {2}\nDespues: {encendidos}\nMotivo: Fuego adyacente y paso libre")

    #Segunda funcion
    def _fuego_estado_1(self, y, x):
        print("\n\n<<<<<<< FUNCION DE FUEGO 1 >>>>>>>>")
        #Caso 'Fuego 1' (la casilla objetivo está en HUMO=1):
        #La celda objetivo pasa a FUEGO=2.
        #Todo HUMO=1 adyacente accesible (sin pared/puerta)
        #también pasa a FUEGO=2; y desde ellos se sigue propagando.
        #Reglas de bloqueo (mismas que en _fuego_estado_0):
        #Pared: 4/2 = BLOQUEA, 0 = NO bloquea.
        #Puerta: 1 = BLOQUEA, 0/2 = NO bloquea.
        #Nos regresa todas las celdas encendidas.

        #Encender la celda objetivo
        estado_inicial = int(self.fire[y, x])
        self.fire[y, x] = 2

        # Guardamos lista de celdas encendidas en este paso (para depurar)
        encendidos = [(x, y)]

        #BFS sobre celdas HUMO=1 alcanzables)
        # Usamos una cola para recorrer por casillas
        por_visitar = [(x, y)]                   # empezamos desde el objetivo ya encendido
        visitados = set([(x, y)])                # para no revisar dos veces la misma casilla

        # vecinos con límites porque la propagación puede alcanzar el borde
        def vecinos_humo(cx, cy):
            W, H = self.grid.width, self.grid.height
            vecinos = [(cx+1, cy), (cx-1, cy), (cx, cy+1), (cx, cy-1)]
            return [(nx, ny) for (nx, ny) in vecinos if 0 <= nx < W and 0 <= ny < H]

        # Dirección NESO desde (cx,cy) hacia (nx,ny)
        def dir_from_to(cx, cy, nx, ny):
            if nx == cx+1 and ny == cy:   return 'E'
            if nx == cx-1 and ny == cy:   return 'W'
            if nx == cx   and ny == cy-1: return 'N'
            if nx == cx   and ny == cy+1: return 'S'

        # Recorremos la cola de humos, expandiendo el fuego si no hay bloqueo
        while por_visitar:
            # sacamos el siguiente origen de casilla
            cx, cy = por_visitar.pop(0)

            # miramos los 4 vecinos de esa casilla
            for nx, ny in vecinos_humo(cx, cy):
                # si ya revisamos esta casilla
                if (nx, ny) in visitados:
                    continue


                # Solo nos interesan vecinos que actualmente estén en HUMO (=1)
                if int(self.fire[ny, nx]) != 1:
                    continue

                # Revisar bloqueo en el segmento (cx,cy) --d--> (nx,ny)
                d = dir_from_to(cx, cy, nx, ny)
                estado_pared  = int(self.walls[cy, cx][d])   # 4/2 bloquea; 0 no bloquea
                print(f"pared: {self.walls[y, x]}")
                estado_puerta = int(self.doors[cy, cx][d])   # 1 bloquea; 0/2 no bloquea
                print(f"puerta: {self.doors[y, x]}")

                # Bloquea si pared != 0 (o sea 2 ó 4) o puerta cerrada (=1)
                #Variable Bandera interna de bloqueo
                bloquea = False

                if estado_pared != 0:
                    bloquea = True
                else:
                    if estado_puerta == 1:
                        bloquea = True
                    else:
                        bloquea = False # pared rota o sin pared y puerta abierta/sin puerta

                if bloquea == True:
                    continue  # no se expande el fuego

                # Si NO bloquea el humos se convierte en FUEGO
                self.fire[ny, nx] = 2
                encendidos.append((nx, ny))
                visitados.add((nx, ny))

                #Y ahora este nuevo fuego puede encender a sus HUMOS vecinos (se va a la cola)
                por_visitar.append((nx, ny))

        # Salida para revisar
        print(f"Origen: {(x, y)}")
        print(f"Antes: {estado_inicial}")
        print(f"Despues: {int(self.fire[y, x])}")
        print(f"Encendidos: {encendidos}")
        print("motivo: FUEGO1_encendido_en_cadena")

        return

    #Tercera funcion
    def _fuego_estado_2_explosion(self, y, x):
        print("\n\n<<<<<<< FUNCION DE FUEGO 2 >>>>>>>>")
        #Explosión desde (x,y) en 2=fuego.
        #En cada dirección N,S,W,E:
          #Si el segmento bloquea (pared 4/2 o puerta 1):
              #pared: resta 2 al valor (mínimo 0) en ambos lados del segmento y detiene esa dirección
              #puerta cerrada: la abre (->2) en ambos lados del segmento y detiene esa dirección
          #Si NO bloquea (pared 0 y puerta !=1):
              #si la celda siguiente está en 2: seguir avanzando
              #si la celda siguiente está en 0 o 1: ponerla en 2 y detener esa dirección
        #Devuelve una traza con celdas encendidas y segmentos modificados.

        # Limites del tablero
        width  = self.grid.width
        height = self.grid.height

        # Direcciones para recorrer
        direcciones = [
            ('N', (0, -1)),
            ('S', (0, +1)),
            ('W', (-1, 0)),
            ('E', (+1, 0)),
        ]

        # Lado opuesto para sincronizar el segmento en la celda vecina
        casilla_opuesta = {'N':'S','S':'N','E':'W','W':'E'}

        encendidos = []         # lista de celdas que pasaron a 2 por la explosión
        paredes_dañadas = []    #Lista paredes dañadas
        puertas_abiertas = []   #Lista puertas abiertas

        #Funcion para encender cadena de humo, como lo ocupamos mucho lo hacemos funcion
        def encender_humo_en_cadena(ox, oy):
            W, H = self.grid.width, self.grid.height
            def vecinos_lim(cx, cy):
                vecinos_ady = [(cx+1,cy),(cx-1,cy),(cx,cy-1),(cx,cy+1)]
                return [(vx,vy) for (vx,vy) in vecinos_ady if 0 <= vx < W and 0 <= vy < H]

            def dir_from_to(cx,cy,nx,ny):
                if nx==cx+1 and ny==cy:   return 'E'
                if nx==cx-1 and ny==cy:   return 'W'
                if nx==cx   and ny==cy-1: return 'N'
                if nx==cx   and ny==cy+1: return 'S'

            #BFS sobre celdas HUMO=1 alcanzables)
            # Usamos una cola para recorrer por casillas
            por_visitar=[(ox,oy)]    # empezamos desde el objetivo ya encendido

            # para no revisar dos veces la misma casilla
            visitados={(ox,oy)}

            # Guardamos lista de celdas encendidas en este pass
            nuevos_encendidos=[]

            # Recorremos la cola de humos, expandiendo el fuego si no hay bloqueo
            while por_visitar:
                # sacamos el siguiente origen de casilla
                cx,cy=por_visitar.pop(0)

                # miramos los 4 vecinos de esa casilla
                for vx,vy in vecinos_lim(cx,cy):
                    # si ya revisamos esta casilla
                    if (vx, vy) in visitados:
                      continue

                    # Solo nos interesan vecinos que actualmente estén en HUMO (=1)
                    if int(self.fire[vy, vx]) != 1:
                        continue

                    # Revisar bloqueo en el segmento (cx,cy) --d--> (nx,ny)
                    d2 = dir_from_to(cx,cy,vx,vy)

                    pared  = int(self.walls[cy,cx][d2]) # 4/2 bloquea; 0 no bloquea
                    print(f"pared: {self.walls[y, x]}")

                    puerta = int(self.doors[cy,cx][d2]) # 1 bloquea; 0/2 no bloquea
                    print(f"puerta: {self.doors[y, x]}")

                    # Bloquea si pared != 0 (o sea 2 ó 4) o puerta cerrada (=1)
                    #Variable Bandera interna de bloqueo
                    bloquea = False

                    if estado_pared != 0:
                        bloquea = True
                    else:
                        if estado_puerta == 1:
                            bloquea = True
                        else:
                            bloquea = False # pared rota o sin pared y puerta abierta/sin puerta

                    if bloquea == True:
                        continue  # no se expande el fuego

                    # Si NO bloquea el humos se convierte en FUEGO
                    self.fire[vy,vx] = 2
                    nuevos_encendidos.append((vx,vy))
                    visitados.add((vx,vy))

                    #Y ahora este nuevo fuego puede encender a sus HUMOS vecinos (se va a la cola)
                    por_visitar.append((vx,vy))
            return nuevos_encendidos

        # Recorremos cada lado uno por uno
        for d,(dx,dy) in direcciones:
            cx,cy = x,y               # empezamos desde el origen en fuego

            while True:
                # Calcular la siguiente celda vecina en la direccion
                # nueva x, nueva y
                nx,ny = cx+dx, cy+dy

                # Si la siguiente celda esta fuera del tablero paramos
                if not (0 <= nx < width and 0 <= ny < height):
                    break

                # Revisar entre la casilla(cx,cy) y nuevo vecino(nx,ny):
                # Pared y puerta del lado 'd' en la celda (cx,cy)
                estado_pared  = int(self.walls[cy,cx][d])
                print(f"pared: {self.walls[y, x]}")

                estado_puerta = int(self.doors[cy,cx][d])
                print(f"puerta: {self.doors[y, x]}")

                bloquea = False

                if estado_pared != 0:
                    bloquea = True
                else:
                    if estado_puerta == 1:
                        bloquea = True
                    else:
                        bloquea = False # pared rota o sin pared y puerta abierta/sin puerta

                if bloquea == True:
                    #Si bloquea por PARED (2 o 4) -> dañamos pared (–2) en ambos lados
                    if estado_pared != 0:
                        antes = estado_pared
                        despues = estado_pared - 2

                        #Sumar daño al contador global
                        self.damage_counter += 2

                        # escribimos en ambos lados de la pared
                        self.walls[cy,cx][d] = despues
                        self.walls[ny,nx][casilla_opuesta[d]] = despues

                        #Añadir registro de la explosión
                        paredes_dañadas.append(((cx,cy), d, antes, despues))

                        # Si quedó rota (0), prende HUMO al otro lado
                        if despues <= 0 and int(self.fire[ny,nx]) == 1:
                            self.fire[ny,nx] = 2
                            #Toma registro de lo encendido
                            encendidos.append((nx,ny))

                            #Manda llamar funcion para prender en cadena
                            encendidos += encender_humo_en_cadena(nx,ny)

                    # Si bloquea por PUERTA  (1) -> abrirla (->2) en ambos lados
                    elif estado_puerta == 1:
                        self.doors[cy,cx][d] = 2
                        self.doors[ny,nx][casilla_opuesta[d]] = 2
                        #Añadir registro de la explosion
                        puertas_abiertas.append(((cx,cy), d))

                        #Manda llamar funcion para prender en cadena
                        if int(self.fire[ny,nx]) == 1:
                            self.fire[ny,nx] = 2
                            #Toma registro de lo encendido
                            encendidos.append((nx,ny))
                            #Manda llamar funcion para prender en cadena
                            encendidos += encender_humo_en_cadena(nx,ny)

                    # Al dañar (pared/puerta), la busqueda en esta dirección se detiene
                    break

                #Si NO bloquea vemos el estado de la casilla vecina (nx,ny)
                estado_vecino = int(self.fire[ny,nx])

                if estado_vecino == 2:
                    #Si el vecino ya es fuego, seguimos bucando en esta direccion
                    #y ahora la casilla vecina sera la que usaremos para bucar al nuevo vecino
                    cx,cy = nx,ny
                    continue

                # Si es 0 lo encendemos y detenemos la busqueda
                self.fire[ny,nx] = 2

                #Añadimos el registro de la explosion y todas las nuevas celdas encendidas
                encendidos.append((nx,ny))
                encendidos += encender_humo_en_cadena(nx,ny)
                break

        # Salida de informacion final
        print(f"Origen: {(x, y)}")
        print(f"Paredes dañadas: {paredes_dañadas}")
        print(f"Puertas abiertas: {puertas_abiertas}")
        print(f"Celdas encendidas: {encendidos}")
        print("motivo: EXPLOSION (con encendido de humos por apertura/rotura)")

        return

    #------------------ Puntos de Interes ------------------------------

    #--------Funcion para pois

    def posicionamiento_POI(self):
        print("\n\n<<<<<<< FUNCION POSICIONAMIENTO POIS >>>>>>>>")
        #Contar POIS en el tablero, sin revelar y revelados
        unrevealed = int((self.pois == 1).sum())
        false_alarms_revealed = int((self.pois == 2).sum())
        victims_revealed = int((self.pois == 3).sum())

        current_pois = unrevealed + false_alarms_revealed + victims_revealed
        pois_placed = self.victims_placed + self.false_alarms_placed

        #Si hay menos de 3 POI se posicionan más
        while current_pois < 3 and self.victims <= 10 and self.false_alarms <= 5:
            victims_left = self.max_victims - self.victims_placed
            false_alarms_left = self.max_false_alarms - self.false_alarms_placed

            #Si ya se colocaron todos los POI se detiene
            if victims_left == 0 and false_alarms_left == 0:
                break

            is_victim = False
            if victims_left > 0 and false_alarms_left > 0:
                poi_probability = victims_left / (victims_left + false_alarms_left)
                is_victim = np.random.random() < poi_probability
            elif victims_left > 0:
                is_victim = True
            elif false_alarms_left > 0:
                is_victim = False
            else:
                break

            attempts = 0
            placed = False
            while attempts < 100 and not placed:
                #Posicionamiento random de POI
                x = np.random.randint(1, 9)
                y = np.random.randint(1, 7)

                if self.pois[y, x] == 0:
                    cell_contents = self.grid.get_cell_list_contents([(x, y)])

                    if self.fire[y, x] == 2:
                        print(f"Apagando fuego en ({x}, {y}) para colocar POI")
                        self.fire[y, x] = 0

                    if len(cell_contents) == 0:
                        #Nuevo POI sin revelar
                        self.pois[y, x] = 1

                        if is_victim:
                            self.poi_type[y, x] = 3
                            self.victims_placed += 1
                            self.victims -= 1

                        else:
                            self.poi_type[y, x] = 2
                            self.false_alarms_placed += 1
                            self.false_alarms -= 1


                        current_pois += 1
                        pois_placed += 1
                        placed = True

                        print(f"Nuevo POI colocado en: ({x}, {y}), victimas colocadas: {self.victims_placed}, Falsas alarmas colocadas: {self.false_alarms_placed}")
                        break

                attempts += 1

            if placed:
                # Role assign
                self.assignRoles()
                break

            if not placed:
                print("No se pudo colocar el POI")
                break

    #--------Funcion para random POI

    def random_POI(self):
        poi_positions = []
        for y in range(1, 7):
            for x in range(1, 9):
                if self.pois[y, x] == 1:
                    poi_positions.append((x, y))

        for (x, y) in poi_positions:
            victims_left = self.max_victims - self.victims_placed
            false_alarms_left = self.max_false_alarms - self.false_alarms_placed

            if victims_left > 0 and false_alarms_left > 0:
                poi_probability = victims_left / (victims_left + false_alarms_left)
                if np.random.random() < poi_probability:
                    self.poi_type[y, x] = 3
                    self.victims_placed += 1
                else:
                    self.poi_type[y, x] = 2
                    self.false_alarms_placed += 1

            elif victims_left > 0:
                self.poi_type[y, x] = 3
                self.victims_placed += 1
            elif false_alarms_left > 0:
                self.poi_type[y, x] = 2
                self.false_alarms_placed += 1


    #------------------ Funcion para pois incendidados
    def poi_incenciados(self):
        print(f"Entra a la funcion de pois incendiados")
        poi_positions = []
        for y in range(1, 7):
            for x in range(1, 9):
                if self.pois[y, x] > 0 and self.fire[y, x] == 2:
                    poi_positions.append((x, y))

        for (x, y) in poi_positions:
            poi = self.pois[y, x]
            poi_type = self.poi_type[y, x]

            if poi_type == 3:
                self.victims_dead += 1
                print(f"Víctima revelada en ({x},{y}) murió por incendio. Total muertos: {self.victims_dead}")

            elif poi_type == 2:
                print(f"Falsa alarma en ({x},{y}) revelada por incendio.")

            # Borrar el POI de la celda incendiada
            self.pois[y, x] = 0
            self.poi_type[y, x] = 0

        if len(poi_positions) > 0:
            # Call posicionamiento_POI to replace the lost POI
            self.posicionamiento_POI()


    #Reposicionamiento de agentes Incendiados------------------------
    def agentes_incendiados(self):
      print("\n\n<<<<<<< FUNCION DE AGENTES INCENDIADOS >>>>>>>>")
      #Recoloca a los agentes cuya casilla actual tiene FUEGO (=2).
      #puertas_ext: lista de coordenadas destino.
    #no enviar agentes a una puerta que también tenga fuego.

      # Psiciones de reubicación
      puertas_ext = [(0, 3), (3, 7), (9, 4), (6, 0)]  # ← tu lista

      reubicados = []      # [{agente, de, a}]
      sin_espacio = []     # [{agente, pos}] si no encontró lugar

      width = self.grid.width
      height = self.grid.height

      # Recorremos a los agentes del scheduler
      for ag in list(self.schedule.agents):
          pos = ag.pos
          x, y = pos

          #Revisar si el agente no esta parado sobre una casilla con fuego se pasa al siguiente
          if int(self.fire[y, x]) != 2:
              print("<<<<<<< NADIE INCENDIADO >>>>>>>>")
              continue

          # Buscar la primera puerta libre
          movido = False
          for (px, py) in puertas_ext:
              # Si la celda no esta libre pasamos a la siguiente
              if not self.grid.is_cell_empty((px, py)):
                  continue
              # Si la celda tiene fuego pasamos a la siguiente
              if int(self.fire[py, px]) == 2:
                  continue

              # Movemos al agente
              self.grid.move_agent(ag, (px, py))
              reubicados.append({
                  "agente": getattr(ag, "unique_id", repr(ag)),
                  "de": (x, y),
                  "a": (px, py)
              })
              movido = True
              break

          if movido == False:
              # No había puerta disponible para el agente herido
              sin_espacio.append({
                  "agente": getattr(ag, "unique_id", repr(ag)),
                  "pos": (x, y)
              })

      return {
          "reubicados": reubicados,
          "sin_espacio": sin_espacio,
          "puertas_consideradas": puertas_ext
      }

    #Paso de la simulacion del modelo
    def step(self):
        self.datacollector.collect(self) # Primero recolecta los datos antes de moverse
        self.victims_saved = sum(agent.victims_saved for agent in self.schedule.agents)
        # Agent List
        agents_list = list(self.schedule.agents)
        # Error check
        if agents_list:
            # call only current agent
            agent = agents_list[self.current_agent_idx]

            self.update_graph_weights(agent.carrying_victim)

            agent.step()
            # Update Index
            self.current_agent_idx = (self.current_agent_idx + 1) % len(agents_list)

        #REVISAR YESS DEBE ESTAR EN EL AGENTE NO ?
        '''self.posicionamiento_POI()
        self.poi_incenciados()'''


    #funcion condicion de termino
    def finish_game(self):
      print("\n\n<<<<<<< REVISION SI SE ACABO EL JUEGO >>>>>>>>")
      #Revisa las condiciones de paro del juego.
        #Gana si hay 7 personas salvadas.
        #Pierde si hay 4 muertos.
        #Pierde si el daño estructural llega a 48.
      #Devuelve: True si terminó, False si sigue.

      # Inicializa flags para datacollector
      self.finished = False
      self.win      = None
      self.reason   = None

      # Lee contadores globales del modelo
      danio = self.damage_counter
      print(f"Daño Actual: {self.damage_counter}")



      #Termina si salva a 7 victimas
      self.victims_saved = sum(agent.victims_saved for agent in self.schedule.agents)
      if self.victims_saved >= 7:
          self.finished = True
          self.win      = True
          self.reason   = 'victims'
          self.running  = False
          print(f"GANASTE Victimas salvadas: {self.victims_saved}, Muertes: {self.victims_dead}, Daño {self.damage_counter}")
          return True

      #REVISAR
      #Termina si murieron 4 victimas
      if self.victims_dead >= 4:
          self.finished = True
          self.win      = False
          self.reason   = 'victims deads'
          self.running  = False
          print(f"PERDISTE Victimas salvadas: {self.victims_saved}, Muertes: {self.victims_dead}, Daño {self.damage_counter}")
          return True

      #Revisar si la estructura colapso (48)
      if danio >= 48:
          self.finished = True
          self.win      = False
          self.reason   = 'damage'
          self.running  = False
          print(f"PERDISTE Victimas salvadas: {self.victims_saved}, Muertes: {self.victims_dead}, Daño {self.damage_counter}")
          return True

      #El juego sigue
      self.finished = False
      self.win      = None
      self.reason   = None
      return False